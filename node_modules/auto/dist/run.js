#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = tslib_1.__importDefault(require("@auto-it/core"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const terminal_link_1 = tslib_1.__importDefault(require("terminal-link"));
/** Spin up the "auto" node API and provide it the parsed CLI args. */
async function run(command, args) {
    var _a, _b;
    const auto = new core_1.default(args);
    try {
        if (command === "init") {
            await auto.init();
            return;
        }
        await auto.loadConfig();
        if (args.verbose || command === "info") {
            try {
                // We don't want auto.info throwing an error during another
                // command
                const { hasError } = await auto.info(args);
                if (command === "info") {
                    // eslint-disable-next-line max-depth
                    if (hasError) {
                        process.exit(1);
                    }
                    else {
                        return;
                    }
                }
            }
            catch (error) {
                if (command === "info") {
                    process.exit(1);
                }
            }
        }
        switch (command) {
            case "create-labels":
                await auto.createLabels(args);
                break;
            case "label":
                await auto.label(args);
                break;
            case "pr-check":
                await auto.prCheck(args);
                break;
            case "pr-status":
                await auto.prStatus(args);
                break;
            case "comment":
                await auto.comment(args);
                break;
            case "pr-body":
                await auto.prBody(args);
                break;
            case "version":
                await auto.version(args);
                break;
            case "changelog":
                await auto.changelog(args);
                break;
            case "release":
                await auto.runRelease(args);
                break;
            case "shipit":
                await auto.shipit(args);
                break;
            case "latest":
                await auto.latest(args);
                break;
            case "canary":
                await auto.canary(args);
                break;
            case "next":
                await auto.next(args);
                break;
            default:
                throw new Error(`idk what i'm doing.`);
        }
    }
    catch (error) {
        if (error.status === 404) {
            const [, project] = await await_to_js_1.default(auto.git.getProject());
            const repoLink = terminal_link_1.default(`${(_a = auto.git) === null || _a === void 0 ? void 0 : _a.options.owner}/${(_b = auto.git) === null || _b === void 0 ? void 0 : _b.options.repo}`, (project === null || project === void 0 ? void 0 : project.html_url) || "");
            auto.logger.log.error(endent_1.default `
        Received 404!

        This usually because the GitHub token you're using doesn't have the correct permissions to the repo.
        
        The token used with auto must have at least "write" permission to your repo (${repoLink}) to create releases and labels.

        You can check the permission for you token by running "auto info".
      `);
            console.log("");
            auto.logger.verbose.error(error.request);
        }
        else {
            console.log(error);
        }
        process.exit(1);
    }
}
exports.run = run;
/** Run "auto" for a given command. */
async function main(command, args) {
    await run(command, args);
}
exports.default = main;
//# sourceMappingURL=run.js.map