"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@auto-it/core");
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const endent_1 = tslib_1.__importDefault(require("endent"));
const bot_list_1 = tslib_1.__importDefault(require("@auto-it/bot-list"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const anymatch_1 = tslib_1.__importDefault(require("anymatch"));
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const child_process_1 = require("child_process");
const t = tslib_1.__importStar(require("io-ts"));
const fromentries_1 = tslib_1.__importDefault(require("fromentries"));
const contributionTypes = [
    "blog",
    "bug",
    "business",
    "code",
    "content",
    "design",
    "doc",
    "eventOrganizing",
    "example",
    "financial",
    "fundingFinding",
    "ideas",
    "infra",
    "maintenance",
    "platform",
    "plugin",
    "projectManagement",
    "question",
    "review",
    "security",
    "talk",
    "test",
    "tool",
    "translation",
    "tutorial",
    "userTesting",
    "video",
];
const isContribution = 
/**
ccccccccccccccccccccccc *
ccccccccccccccccccccccc */
(contribution) => contributionTypes.includes(contribution);
/** Get an rc file if there is one. */
function getRcFile() {
    try {
        const rcFile = path_1.default.join(process.cwd(), ".all-contributorsrc");
        const config = JSON.parse(fs_1.default.readFileSync(rcFile, "utf8"));
        return config;
    }
    catch (error) { }
}
const pattern = t.union([t.string, t.array(t.string)]);
const pluginOptions = t.partial({
    /** Usernames to exclude from the contributors */
    exclude: t.array(t.string),
    /** Globs to detect change types by */
    types: t.partial(fromentries_1.default(contributionTypes.map((c) => [c, pattern]))),
});
const defaultOptions = {
    exclude: bot_list_1.default,
    types: {
        doc: ["**/*.mdx", "**/*.md", "**/docs/**/*", "**/documentation/**/*"],
        example: ["**/*.stories*", "**/*.story.*"],
        infra: ["**/.circle/**/*", "**/.github/**/*", "**/travis.yml"],
        test: ["**/*.test.*", "**/test/**", "**/__tests__/**"],
        code: ["**/src/**/*", "**/lib/**/*", "**/package.json", "**/tsconfig.json"],
    },
};
const title = /[#]{0,5}[ ]*[C|c]ontributions/;
const contributorLine = /^[-*] @(\S+)\s+[:-]\s+([\S ,]+)$/;
/** Find contributions listed in PR bodies */
function getExtraContributors(body) {
    const authorContributions = {};
    if (!body) {
        return;
    }
    const start = body.match(title);
    if (!start) {
        return;
    }
    body
        .slice((start.index || 0) + (start[0] || "").length)
        .replace(/\r\n/g, "\n")
        .split("\n")
        .forEach((line) => {
        if (line.startsWith("#") || line.startsWith("<!--")) {
            return;
        }
        const contributor = line.match(contributorLine);
        if (!contributor) {
            return;
        }
        const [, username, contributions] = contributor;
        if (!authorContributions[username]) {
            authorContributions[username] = new Set();
        }
        contributions
            .split(",")
            .map((contribution) => contribution.trim())
            .forEach((contribution) => authorContributions[username].add(contribution));
    });
    return authorContributions;
}
/** Automatically add contributors as changelogs are produced. */
class AllContributorsPlugin {
    /** Initialize the plugin with it's options */
    constructor(options = {}) {
        /** The name of the plugin */
        this.name = "all-contributors";
        this.options = {
            exclude: [...(defaultOptions.exclude || []), ...(options.exclude || [])],
            types: Object.assign(Object.assign({}, defaultOptions.types), options.types),
        };
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        const env = env_ci_1.default();
        auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {
            if (name === this.name || name === `@auto-it/${this.name}`) {
                return core_1.validatePluginConfiguration(this.name, pluginOptions, options);
            }
        });
        auto.hooks.beforeShipIt.tapPromise(this.name, async (context) => {
            var _a;
            if (context.releaseType === "latest" ||
                context.releaseType === "old" ||
                !("pr" in env)) {
                return;
            }
            const pr = Number(env.pr);
            if (!pr) {
                return;
            }
            const prInfo = await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getPullRequest(pr));
            auto.logger.log.info(this.name, { prInfo });
            if (!prInfo) {
                return;
            }
            const extra = getExtraContributors(prInfo.data.body);
            auto.logger.log.info(this.name, { extra });
            if (!extra || !Object.keys(extra).length) {
                return;
            }
            const allContributions = Object.values(extra).reduce((all, i) => [...all, ...i], []);
            const unknownTypes = allContributions.filter((contribution) => !contributionTypes.includes(contribution));
            const hasValidTypes = allContributions.length !== unknownTypes.length;
            const message = endent_1.default `
        # Extra Contributions

        ${hasValidTypes
                ? endent_1.default `
              The following contributions will be added to all-contributors (as well as any code contributions) when this PR is released :tada::

              ${Object.entries(extra).map(([username, contributions]) => {
                    const validContributions = [...contributions].filter(isContribution);
                    if (!validContributions.length) {
                        return "";
                    }
                    return `- @${username} - ${validContributions.join(", ")}`;
                }).filter(Boolean).join('\n')}
            `
                : "No valid contribution types found!"}

        ${unknownTypes.length
                ? endent_1.default `
                ## Unknown Contribution Types

                We found some unknown contribution types in your PR body!
                These contributions will not be counted and you should fix them.

                ${unknownTypes.map((type) => `- \`${type}\``)}
              `
                : ""}
      `;
            await auto.comment({
                pr,
                context: "Extra Contributions",
                edit: true,
                message,
            });
        });
        auto.hooks.afterAddToChangelog.tapPromise(this.name, async ({ commits }) => {
            const rootDir = process.cwd();
            // Always do the root package
            let packages = [{ path: rootDir, name: "root-package" }];
            try {
                // Try to get sub-packages
                packages = [...packages, ...(await core_1.getLernaPackages())];
            }
            catch (error) { }
            // Go through each package and update code contributions
            await packages.reduce(async (last, { name, path }) => {
                // Cannot run git operations in parallel
                await last;
                auto.logger.verbose.info(`Updating contributors for: ${name}`);
                const includedCommits = commits.filter((commit) => commit.files.some((file) => core_1.inFolder(path, file)));
                if (includedCommits.length > 0) {
                    auto.logger.verbose.success(`${name} has ${includedCommits.length} new commits.`);
                    auto.logger.veryVerbose.info(`With commits: ${JSON.stringify(includedCommits, null, 2)}`);
                    process.chdir(path);
                    await this.updateContributors(auto, includedCommits);
                }
            }, Promise.resolve());
            process.chdir(rootDir);
            const changedFiles = await core_1.execPromise("git", [
                "status",
                "--porcelain",
            ]);
            if (changedFiles) {
                await core_1.execPromise("git", ["add", "README.md"]);
                await core_1.execPromise("git", ["add", ".all-contributorsrc"]);
                await await_to_js_1.default(core_1.execPromise("git", ["add", "**/README.md"]));
                await await_to_js_1.default(core_1.execPromise("git", ["add", "**/.all-contributorsrc"]));
                await core_1.execPromise("git", [
                    "commit",
                    "--no-verify",
                    "-m",
                    '"Update contributors [skip ci]"',
                ]);
            }
        });
    }
    /** Update the contributors rc for a package. */
    async updateContributors(auto, commits) {
        const config = getRcFile();
        if (!config) {
            return;
        }
        const authorContributions = {};
        let didUpdate = false;
        const commitsWithAllChangedFiles = await Promise.all(commits.map(async (commit) => {
            const extra = await core_1.execPromise("git", [
                "show",
                '--pretty=""',
                "--name-only",
                "--first-parent",
                "-m",
                commit.hash,
            ]);
            commit.files = [...new Set([...commit.files, ...extra.split("\n")])];
            return commit;
        }));
        // 1. Find all the authors and their contribution types
        commitsWithAllChangedFiles.forEach((commit) => {
            const { authors } = commit;
            let { files } = commit;
            // Find automated contribution for type globs
            Object.keys(this.options.types || {})
                .filter((type) => {
                /** Determine if path is the contribution type */
                const isType = (file) => anymatch_1.default(this.options.types[type] || [], file);
                const isMatch = files.some(isType);
                files = files.filter((file) => !isType(file));
                return isMatch;
            })
                .forEach((contribution) => {
                authors.forEach(({ username }) => {
                    if (!username) {
                        return;
                    }
                    if (!authorContributions[username]) {
                        authorContributions[username] = new Set();
                    }
                    authorContributions[username].add(contribution);
                });
            });
            // Find contributions listed in PR bodies
            const extra = getExtraContributors(commit.rawBody);
            if (extra) {
                Object.entries(extra).forEach(([username, contributions]) => {
                    if (!authorContributions[username]) {
                        authorContributions[username] = new Set();
                    }
                    [...contributions]
                        .filter(isContribution)
                        .forEach((contribution) => authorContributions[username].add(contribution));
                });
            }
        });
        auto.logger.verbose.info("Found contributions:", authorContributions);
        // 2. Determine if contributor has update
        Object.entries(authorContributions).forEach(([username, contributions]) => {
            const { contributions: old = [] } = config.contributors.find((contributor) => contributor.login.toLowerCase() === username.toLowerCase()) || {};
            const hasNew = [...contributions].find((contribution) => !old.includes(contribution));
            if (hasNew && !this.options.exclude.includes(username)) {
                const newContributions = new Set([...old, ...contributions]);
                didUpdate = true;
                auto.logger.log.info(`Adding "${username}"'s contributions...`);
                child_process_1.execSync(`npx all-contributors-cli add ${username} ${[
                    ...newContributions,
                ].join(",")}`, { stdio: "inherit" });
            }
            else {
                auto.logger.verbose.warn(`"${username}" had no new contributions...`);
            }
        });
        if (didUpdate) {
            auto.logger.log.success("Updated contributors!");
        }
    }
}
exports.default = AllContributorsPlugin;
//# sourceMappingURL=index.js.map