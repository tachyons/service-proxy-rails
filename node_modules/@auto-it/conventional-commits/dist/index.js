"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parse_commit_message_1 = require("parse-commit-message");
const core_1 = require("@auto-it/core");
/**
 * Parse conventional commit messages and use them to
 * calculate the version.
 */
class ConventionalCommitsPlugin {
    constructor() {
        /** The name of the plugin */
        this.name = "conventional-commits";
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        auto.hooks.onCreateLogParse.tap(this.name, (logParse) => {
            logParse.hooks.parseCommit.tap(this.name, (commit) => {
                if (!auto.semVerLabels) {
                    return commit;
                }
                try {
                    const [conventionalCommit] = parse_commit_message_1.applyPlugins(parse_commit_message_1.mappers.increment, parse_commit_message_1.parse(commit.subject));
                    // conventional commits will return a falsy value when no incrememnt is detected (e.g., chore/perf/refactor commits)
                    const commitIncrement = conventionalCommit.increment || "skip";
                    const incrementLabel = auto.semVerLabels.get(commitIncrement);
                    const allSemVerLabels = [
                        auto.semVerLabels.get(core_1.SEMVER.major),
                        auto.semVerLabels.get(core_1.SEMVER.minor),
                        auto.semVerLabels.get(core_1.SEMVER.patch),
                    ].reduce((acc, labels) => (labels ? [...acc, ...labels] : acc), []);
                    if (conventionalCommit.header &&
                        incrementLabel &&
                        !commit.labels.some((l) => allSemVerLabels.includes(l))) {
                        commit.labels = [...commit.labels, ...incrementLabel];
                    }
                }
                catch (error) {
                    auto.logger.verbose.info(`No conventional commit message found for ${commit.hash}`);
                }
                return commit;
            });
            // should omit PR commit if there exists a commit with a CC commit message
            logParse.hooks.omitCommit.tapPromise(this.name, async (commit) => {
                if (auto.git &&
                    auto.release &&
                    commit.pullRequest &&
                    commit.labels.length === 0) {
                    const prCommits = await auto.git.getCommitsForPR(commit.pullRequest.number);
                    // Omit the commit if one of the commits in the PR contains a CC message since it will already be counted
                    return Boolean(prCommits.find((c) => {
                        try {
                            return Boolean(parse_commit_message_1.parse(c.commit.message)[0].header);
                        }
                        catch (error) {
                            return false;
                        }
                    }));
                }
            });
        });
    }
}
exports.default = ConventionalCommitsPlugin;
//# sourceMappingURL=index.js.map