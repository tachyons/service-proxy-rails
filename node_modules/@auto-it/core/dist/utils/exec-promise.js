"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const logger_1 = tslib_1.__importDefault(require("./logger"));
const log = logger_1.default();
/**
 * Wraps up running a command into a single promise,
 * returning the stdout as a string if the command succeeds
 * and throwing if it does not.
 *
 * @param cmd - the command as a string to pass in
 */
async function execPromise(cmd, args = []) {
    const callSite = new Error().stack;
    const filteredArgs = args.filter((arg) => typeof arg === "string");
    return new Promise((completed, reject) => {
        const child = child_process_1.spawn(cmd, filteredArgs, {
            cwd: process.cwd(),
            env: process.env,
            shell: true,
        });
        let allStdout = "";
        let allStderr = "";
        if (child.stdout) {
            child.stdout.on("data", async (data) => {
                const stdout = data.toString();
                allStdout += stdout;
            });
        }
        if (child.stderr) {
            child.stderr.on("data", (data) => {
                const stderr = data.toString();
                allStderr += stderr;
            });
        }
        // This usually occurs during dev-time, when you have the wrong command
        child.on("error", (err) => {
            reject(new Error(`Failed to run '${cmd}' - ${err.message} \n\n\n${allStderr}`));
        });
        child.on("exit", (code) => {
            // No code, no errors
            if (code) {
                // The command bailed for whatever reason, print a verbose error message
                // with the stdout underneath
                let appendedStdErr = "";
                appendedStdErr += allStdout.length ? `\n\n${allStdout}` : "";
                appendedStdErr += allStderr.length ? `\n\n${allStderr}` : "";
                const error = new Error(`Running command '${cmd}' with args [${args.join(", ")}] failed${appendedStdErr}`);
                error.stack = (error.stack || "") + callSite;
                reject(error);
            }
            else {
                // Tools can occasionally print to stderr but not fail, so print that just in case.
                if (allStderr.length) {
                    log.log.warn(allStderr);
                }
                // Resolve the string of the whole stdout
                completed(allStdout.trim());
            }
        });
    });
}
exports.default = execPromise;
//# sourceMappingURL=exec-promise.js.map