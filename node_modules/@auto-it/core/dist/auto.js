"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const dotenv_1 = tslib_1.__importDefault(require("dotenv"));
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const terminal_link_1 = tslib_1.__importDefault(require("terminal-link"));
const log_symbols_1 = tslib_1.__importDefault(require("log-symbols"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const semver_1 = require("semver");
const endent_1 = tslib_1.__importDefault(require("endent"));
const url_1 = require("url");
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const https_proxy_agent_1 = tslib_1.__importDefault(require("https-proxy-agent"));
const semver_2 = require("./semver");
const config_1 = tslib_1.__importDefault(require("./config"));
const git_1 = tslib_1.__importDefault(require("./git"));
const init_1 = tslib_1.__importDefault(require("./init"));
const release_1 = tslib_1.__importStar(require("./release"));
const semver_3 = tslib_1.__importStar(require("./semver"));
const exec_promise_1 = tslib_1.__importDefault(require("./utils/exec-promise"));
const load_plugins_1 = require("./utils/load-plugins");
const logger_1 = tslib_1.__importStar(require("./utils/logger"));
const make_hooks_1 = require("./utils/make-hooks");
const get_current_branch_1 = require("./utils/get-current-branch");
const match_sha_to_pr_1 = require("./match-sha-to-pr");
const get_repository_1 = tslib_1.__importDefault(require("./utils/get-repository"));
const validate_config_1 = require("./validate-config");
const omit_1 = require("./utils/omit");
const child_process_1 = require("child_process");
const is_binary_1 = tslib_1.__importDefault(require("./utils/is-binary"));
const git_reset_1 = require("./utils/git-reset");
const proxyUrl = process.env.https_proxy || process.env.http_proxy;
const env = env_ci_1.default();
/** Make a HTML detail */
const makeDetail = (summary, body) => endent_1.default `
  <details>
    <summary>${summary}</summary>
    <br />
    
    ${body}
  </details>
`;
/** Load the .env file into process.env. Useful for local usage. */
const loadEnv = () => {
    const envFile = path_1.default.resolve(process.cwd(), ".env");
    if (!fs_1.default.existsSync(envFile)) {
        return;
    }
    const envConfig = dotenv_1.default.parse(fs_1.default.readFileSync(envFile));
    Object.entries(envConfig).forEach(([key, value]) => {
        process.env[key] = value;
    });
};
/** Get the pr number from user input or the CI env. */
function getPrNumberFromEnv(pr) {
    const envPr = "pr" in env && Number(env.pr);
    const prNumber = pr || envPr;
    return prNumber;
}
/**
 * Bump the version but no too much.
 *
 * @example
 * currentVersion = 1.0.0
 * nextVersion = 2.0.0-next.0
 * output = 2.0.0-next.1
 */
function determineNextVersion(lastVersion, currentVersion, bump, tag) {
    const next = semver_1.inc(lastVersion, `pre${bump}`, tag);
    return !next || semver_1.lte(next, currentVersion)
        ? semver_1.inc(currentVersion, "prerelease", tag) || "prerelease"
        : next;
}
exports.determineNextVersion = determineNextVersion;
/** Print the current version of "auto" */
function getAutoVersion() {
    const packagePath = path_1.default.join(__dirname, "../package.json");
    const packageJson = JSON.parse(fs_1.default.readFileSync(packagePath, "utf8"));
    return packageJson.version;
}
exports.getAutoVersion = getAutoVersion;
/** Escape a string for use in a Regex */
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
/**
 * The "auto" node API. Its public interface matches the
 * commands you can run from the CLI
 */
class Auto {
    /** Initialize auto and it's environment */
    constructor(options = {}) {
        /** Check if `git status` is clean. */
        this.checkClean = async () => {
            const status = await exec_promise_1.default("git", ["status", "--porcelain"]);
            if (!status) {
                return;
            }
            this.logger.log.error("Changed Files:\n", status);
            throw new Error("Working direction is not clean, make sure all files are committed");
        };
        /** Prefix a version with a "v" if needed */
        this.prefixRelease = (release) => {
            var _a;
            if (!this.release) {
                throw this.createErrorMessage();
            }
            return ((_a = this.config) === null || _a === void 0 ? void 0 : _a.noVersionPrefix) || release.startsWith("v")
                ? release
                : `v${release}`;
        };
        this.options = options;
        this.baseBranch = options.baseBranch || "master";
        logger_1.setLogLevel("quiet" in options && options.quiet
            ? "quiet"
            : Array.isArray(options.verbose) && options.verbose.length > 1
                ? "veryVerbose"
                : options.verbose
                    ? "verbose"
                    : undefined);
        this.logger = logger_1.default();
        this.hooks = make_hooks_1.makeHooks();
        this.hooks.getRepository.tapPromise("Get repo info from origin", get_repository_1.default);
        this.hooks.onCreateRelease.tap("Link onCreateChangelog", (release) => {
            release.hooks.onCreateChangelog.tap("Link onCreateChangelog", (changelog, version) => {
                this.hooks.onCreateChangelog.call(changelog, version);
            });
        });
        this.hooks.onCreateRelease.tap("Link onCreateLogParse", (release) => {
            release.hooks.onCreateLogParse.tap("Link onCreateLogParse", (logParse) => {
                this.hooks.onCreateLogParse.call(logParse);
            });
        });
        this.hooks.beforeCommitChangelog.tapPromise("Old Version Branches", async ({ bump }) => {
            var _a, _b;
            if (bump === semver_3.default.major && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.versionBranches)) {
                const branch = `${this.config.versionBranches}${semver_1.major(await this.hooks.getPreviousVersion.promise())}`;
                await exec_promise_1.default("git", [
                    "branch",
                    await ((_b = this.git) === null || _b === void 0 ? void 0 : _b.getLatestTagInBranch()),
                ]);
                await exec_promise_1.default("git", ["push", this.remote, branch]);
            }
        });
        /**
         * Determine if repo is behind HEAD of current branch. We do this in
         * the "afterVersion" hook so the check happens as late as possible.
         */
        this.hooks.afterVersion.tapPromise("Check remote for commits", async () => {
            // Credit from https://github.com/semantic-release/semantic-release/blob/b2b7b57fbd51af3fe25accdd6cd8499beb9005e5/lib/git.js#L179
            // `true` is the HEAD of the current local branch is the same as the HEAD of the remote branch, falsy otherwise.
            try {
                const currentBranch = get_current_branch_1.getCurrentBranch();
                const heads = await exec_promise_1.default("git", [
                    "ls-remote",
                    "--heads",
                    this.remote,
                    currentBranch,
                ]);
                this.logger.verbose.info("Branch:", currentBranch);
                this.logger.verbose.info("HEADs:", heads);
                const [, remoteHead] = heads.match(/^(\w+)?/) || [];
                if (remoteHead) {
                    // This will throw if the branch is ahead of the current branch
                    child_process_1.execSync(`git merge-base --is-ancestor ${remoteHead} HEAD`, {
                        stdio: "ignore",
                    });
                }
                this.logger.verbose.info("Current branch is up to date, proceeding with release");
            }
            catch (error) {
                // If we are behind or there is no match, exit and skip the release
                this.logger.log.warn("Current commit is behind, skipping the release to avoid collisions.");
                this.logger.verbose.warn(error);
                process.exit(0);
            }
        });
        loadEnv();
        this.logger.verbose.info("ENV:", env);
    }
    /** List some of the plugins available to auto */
    async listPlugins() {
        await load_plugins_1.listPlugins(this.config, this.logger, this.getExtendedLocation(this.config));
    }
    /**
     * Load the default hook behaviors. Should run after loadPlugins so
     * plugins take precedence.
     */
    loadDefaultBehavior() {
        this.hooks.makeRelease.tapPromise("Default", async (options) => {
            if (options.dryRun) {
                const bump = await this.getVersion({ from: options.from });
                this.logger.log.info(`Would have created a release on GitHub for version: ${semver_1.inc(options.newVersion, bump)}`);
                this.logger.log.note('The above version would only get released if ran with "shipit" or a custom script that bumps the version using the "version" command');
            }
            else {
                this.logger.log.info(`Releasing ${options.newVersion} to GitHub.`);
                const release = await this.git.publish(options.fullReleaseNotes, options.newVersion, options.isPrerelease);
                this.logger.log.info(release.data.html_url);
                return release;
            }
        });
    }
    /**
     * Load the .autorc from the file system, set up defaults, combine with CLI args
     * load the extends property, load the plugins and start the git remote interface.
     */
    async loadConfig() {
        const configLoader = new config_1.default(this.logger);
        const userConfig = await configLoader.loadConfig();
        this.logger.verbose.success("Loaded `auto` with config:", userConfig);
        // Allow plugins to be overriden for testing
        this.config = Object.assign(Object.assign({}, userConfig), { plugins: this.options.plugins || userConfig.plugins });
        this.loadPlugins(this.config);
        this.loadDefaultBehavior();
        this.config = this.hooks.modifyConfig.call(this.config);
        this.labels = this.config.labels;
        this.semVerLabels = release_1.getVersionMap(this.config.labels);
        this.hooks.beforeRun.call(this.config);
        const errors = [
            ...(await validate_config_1.validateAutoRc(this.config)),
            ...(await validate_config_1.validatePlugins(this.hooks.validateConfig, this.config)),
        ];
        if (errors.length) {
            this.logger.log.error(endent_1.default `
          Found configuration errors:
          
          ${errors.map(validate_config_1.formatError).join("\n")}
        `, "\n");
            this.logger.log.warn("These errors are for the fully loaded configuration (this is why some paths might seem off).");
            if (this.config.extends) {
                this.logger.log.warn("Some errors might originate from an extend config.");
            }
            process.exit(1);
        }
        const config = Object.assign(Object.assign(Object.assign({}, this.config), omit_1.omit(this.options, ["_command", "_all", "main"])), { baseBranch: this.baseBranch });
        this.config = config;
        const repository = await this.getRepo(config);
        const token = (repository === null || repository === void 0 ? void 0 : repository.token) || process.env.GH_TOKEN || process.env.GITHUB_TOKEN;
        if (!token || token === "undefined") {
            this.logger.log.error("No GitHub was found. Make sure it is available on process.env.GH_TOKEN.");
            throw new Error("GitHub token not found!");
        }
        const githubOptions = Object.assign(Object.assign({ owner: config.owner, repo: config.repo }, repository), { token, agent: proxyUrl ? https_proxy_agent_1.default(proxyUrl) : undefined, baseUrl: config.githubApi || "https://api.github.com", graphqlBaseUrl: config.githubGraphqlApi || config.githubApi || "https://api.github.com" });
        this.git = this.startGit(githubOptions);
        this.release = new release_1.default(this.git, config, this.logger);
        this.remote = await this.getRemote();
        this.logger.verbose.info(`Using remote: ${this.remote.replace(token, `****${token.substring(0, 4)}`)}`);
        this.hooks.onCreateRelease.call(this.release);
        return config;
    }
    /** Determine the remote we have auth to push to. */
    async getRemote() {
        const [, configuredRemote = "origin"] = await await_to_js_1.default(exec_promise_1.default("git", ["remote", "get-url", "origin"]));
        if (!this.git) {
            return configuredRemote;
        }
        const { html_url } = (await this.git.getProject()) || { html_url: "" };
        const GIT_TOKENS = {
            // GitHub Actions require the "x-access-token:" prefix for git access
            // https://developer.github.com/apps/building-github-apps/authenticating-with-github-apps/#http-based-git-access-by-an-installation
            GITHUB_TOKEN: process.env.GITHUB_ACTION
                ? `x-access-token:${process.env.GITHUB_TOKEN}`
                : undefined,
        };
        const envVar = Object.keys(GIT_TOKENS).find((v) => process.env[v]) || "";
        const gitCredentials = GIT_TOKENS[envVar] || process.env.GH_TOKEN;
        if (gitCredentials) {
            const _a = url_1.parse(html_url), { port, hostname } = _a, parsed = tslib_1.__rest(_a, ["port", "hostname"]);
            const urlWithAuth = url_1.format(Object.assign(Object.assign({}, parsed), { auth: gitCredentials, host: `${hostname}${port ? `:${port}` : ""}` }));
            if (await this.git.verifyAuth(urlWithAuth)) {
                this.logger.veryVerbose.note("Using token + html URL as remote");
                return urlWithAuth;
            }
        }
        if (html_url && (await this.git.verifyAuth(html_url))) {
            this.logger.veryVerbose.note("Using bare html URL as remote");
            return html_url;
        }
        this.logger.veryVerbose.note("Using remote set in environment");
        return configuredRemote;
    }
    /** Interactive prompt for initializing an .autorc */
    async init() {
        const init = new init_1.default(this);
        await init.run();
    }
    /** Check if auto is set up correctly */
    async info(args) {
        var _a, _b;
        if (!this.git) {
            return { hasError: false };
        }
        const [, gitVersion = ""] = await await_to_js_1.default(exec_promise_1.default("git", ["--version"]));
        const [noProject, project] = await await_to_js_1.default(this.git.getProject());
        const repo = (await this.getRepo(this.config)) || {};
        const repoLink = terminal_link_1.default(`${repo.owner}/${repo.repo}`, project === null || project === void 0 ? void 0 : project.html_url);
        const author = (await this.getGitUser()) || {};
        const version = await this.getCurrentVersion(await this.git.getLatestRelease());
        const [err, latestRelease] = await await_to_js_1.default(this.git.getLatestReleaseInfo());
        const latestReleaseLink = latestRelease
            ? terminal_link_1.default(latestRelease.tag_name, latestRelease.html_url)
            : "";
        const { headers } = await this.git.github.request("HEAD /");
        const access = headers;
        const rateLimitRefresh = new Date(Number(access["x-ratelimit-reset"]) * 1000);
        const token = this.git.options.token || "";
        const tokenRefresh = `${rateLimitRefresh.toLocaleTimeString()} ${rateLimitRefresh.toLocaleDateString("en-us")}`;
        const projectLabels = await this.git.getProjectLabels();
        const hasLabels = (_a = this.config) === null || _a === void 0 ? void 0 : _a.labels.reduce((acc, label) => {
            var _a, _b;
            if (label.name === "release" &&
                !((_a = this.config) === null || _a === void 0 ? void 0 : _a.onlyPublishWithReleaseLabel)) {
                return acc;
            }
            if (label.name === "skip-release" && ((_b = this.config) === null || _b === void 0 ? void 0 : _b.onlyPublishWithReleaseLabel)) {
                return acc;
            }
            return acc && projectLabels.includes(label.name);
        }, true);
        const { permission, user } = (await this.git.getTokenPermissionLevel()) || {};
        let hasError = false;
        /** Log if a configuration is correct. */
        const logSuccess = (err) => {
            if (err) {
                hasError = true;
                return log_symbols_1.default.error;
            }
            return log_symbols_1.default.success;
        };
        console.log("");
        // prettier-ignore
        console.log(endent_1.default `
      ${chalk_1.default.underline.white('Environment Information:')}

      "auto" version: v${getAutoVersion()}
      "git"  version: v${gitVersion.replace('git version ', '')}
      "node" version: ${process.version.trim()}${access['x-github-enterprise-version']
            ? `GHE version:    v${access['x-github-enterprise-version']}\n`
            : '\n'}
      ${chalk_1.default.underline.white('Project Information:')}

      ${logSuccess(noProject)} Repository:      ${repoLink}
      ${logSuccess(!author.name)} Author Name:     ${author.name}
      ${logSuccess(!author.email)} Author Email:    ${author.email}
      ${logSuccess(!version)} Current Version: ${this.prefixRelease(version)}
      ${logSuccess(err)} Latest Release:  ${latestReleaseLink}

      ${logSuccess(!hasLabels)} Labels configured on GitHub project ${hasLabels ? '' : '(Try running "auto create-labels")'}

      ${chalk_1.default.underline.white('GitHub Token Information:')}

      ${logSuccess(!token)} Token:            ${`[Token starting with ${token.substring(0, 4)}]`}
      ${logSuccess(!(permission === 'admin' || permission === 'write'))} Repo Permission:  ${permission}
      ${logSuccess(!(user === null || user === void 0 ? void 0 : user.login))} User:             ${user === null || user === void 0 ? void 0 : user.login}
      ${logSuccess()} API:              ${terminal_link_1.default(this.git.options.baseUrl, this.git.options.baseUrl)}
      ${logSuccess(!((_b = access['x-oauth-scopes']) === null || _b === void 0 ? void 0 : _b.includes('repo')))} Enabled Scopes:   ${access['x-oauth-scopes']}
      ${logSuccess(Number(access['x-ratelimit-remaining']) === 0)} Rate Limit:       ${access['x-ratelimit-remaining'] || 'âˆž'}/${access['x-ratelimit-limit'] || 'âˆž'} ${access['ratelimit-reset'] ? `(Renews @ ${tokenRefresh})` : ''}
    `);
        console.log("");
        if (args.listPlugins) {
            await this.listPlugins();
        }
        return { hasError };
    }
    /** Determine if the repo is currently in a prerelease branch */
    inPrereleaseBranch() {
        var _a;
        const branch = get_current_branch_1.getCurrentBranch();
        const prereleaseBranches = (_a = this.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches;
        return Boolean(branch && prereleaseBranches.includes(branch));
    }
    /** Determine if the repo is currently in a old-version branch */
    inOldVersionBranch() {
        var _a;
        const branch = get_current_branch_1.getCurrentBranch();
        const prereleaseBranchPrefix = (_a = this.config) === null || _a === void 0 ? void 0 : _a.versionBranches;
        return Boolean(prereleaseBranchPrefix &&
            branch &&
            new RegExp(`^${escapeRegExp(prereleaseBranchPrefix)}`).test(branch));
    }
    /**
     * Create all of the user's labels on the git remote if the don't already exist
     *
     * @param options - Options for the createLabels functionality
     */
    async createLabels(options = {}) {
        if (!this.release || !this.labels) {
            throw this.createErrorMessage();
        }
        await this.release.addLabelsToProject(this.labels, options);
    }
    /**
     * Get the labels on a specific PR. Defaults to the labels of the last merged PR
     *
     * @param options - Options for the createLabels functionality
     */
    async label({ pr } = {}) {
        if (!this.git) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'label'");
        const number = getPrNumberFromEnv(pr);
        let labels = [];
        if (number) {
            labels = await this.git.getLabels(number);
        }
        else {
            const pulls = await this.git.getPullRequests({
                state: "closed",
            });
            const lastMerged = pulls
                .sort((a, b) => new Date(b.merged_at).getTime() - new Date(a.merged_at).getTime())
                .find((pull) => pull.merged_at);
            if (lastMerged) {
                labels = lastMerged.labels.map((label) => label.name);
            }
        }
        if (labels.length) {
            console.log(labels.join("\n"));
        }
    }
    /**
     * Create a status on a PR.
     *
     * @param options - Options for the pr status functionality
     */
    async prStatus(_a) {
        var { dryRun, pr, url } = _a, options = tslib_1.__rest(_a, ["dryRun", "pr", "url"]);
        if (!this.git) {
            throw this.createErrorMessage();
        }
        let { sha } = options;
        let prNumber;
        try {
            prNumber = this.getPrNumber("pr", pr);
        }
        catch (error) {
            // default to sha if no PR found
        }
        this.logger.verbose.info("Using command: 'pr-status'");
        if (!sha && prNumber) {
            this.logger.verbose.info("Getting commit SHA from PR.");
            const res = await this.git.getPullRequest(prNumber);
            sha = res.data.head.sha;
        }
        else if (!sha) {
            this.logger.verbose.info("No PR found, getting commit SHA from HEAD.");
            sha = await this.git.getSha();
        }
        this.logger.verbose.info("Found PR SHA:", sha);
        const target_url = url;
        if (dryRun) {
            this.logger.verbose.info("`pr` dry run complete.");
        }
        else {
            try {
                await this.git.createStatus(Object.assign(Object.assign({}, options), { sha,
                    target_url }));
            }
            catch (error) {
                throw new Error(`Failed to post status to Pull Request with error code ${error.status}`);
            }
            this.logger.log.success("Posted status to Pull Request.");
        }
        this.logger.verbose.success("Finished `pr` command");
    }
    /**
     * Check that a PR has a SEMVER label. Set a success status on the PR.
     *
     * @param options - Options for the pr check functionality
     */
    async prCheck(_a) {
        var _b, _c;
        var { dryRun, pr, url } = _a, options = tslib_1.__rest(_a, ["dryRun", "pr", "url"]);
        if (!this.git || !this.release || !this.semVerLabels) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info(`Using command: 'pr-check' for '${url}'`);
        const target_url = url;
        const prNumber = this.getPrNumber("prCheck", pr);
        let msg;
        let sha;
        try {
            const res = await this.git.getPullRequest(prNumber);
            sha = res.data.head.sha;
            const labels = await this.git.getLabels(prNumber);
            const labelValues = [...this.semVerLabels.values()];
            const releaseTag = labels.find((l) => l === "release");
            const skipReleaseLabels = (((_b = this.config) === null || _b === void 0 ? void 0 : _b.labels.filter((l) => l.releaseType === "skip")) || []).map((l) => l.name);
            const skipReleaseTag = labels.find((l) => skipReleaseLabels.includes(l));
            const semverTag = labels.find((l) => labelValues.some((labelValue) => labelValue.includes(l)) &&
                !skipReleaseLabels.includes(l) &&
                l !== "release");
            const branch = get_current_branch_1.getCurrentBranch();
            if (branch && ((_c = this.config) === null || _c === void 0 ? void 0 : _c.prereleaseBranches.includes(branch))) {
                msg = {
                    description: "PR will graduate prerelease once merged",
                    state: "success",
                };
            }
            else if (semverTag === undefined && !skipReleaseTag) {
                throw new Error("No semver label!");
            }
            else {
                this.logger.log.success(`PR is using label: ${semverTag || skipReleaseTag}`);
                let description;
                if (skipReleaseTag) {
                    description = "PR will not create a release";
                }
                else if (releaseTag) {
                    description = `PR will create release once merged - ${semverTag}`;
                }
                else {
                    description = `CI - ${semverTag}`;
                }
                msg = {
                    description,
                    state: "success",
                };
            }
        }
        catch (error) {
            msg = {
                description: error.message,
                state: "error",
            };
        }
        this.logger.verbose.info("Posting status to GitHub\n", msg);
        if (dryRun) {
            this.logger.verbose.info("`pr-check` dry run complete.");
        }
        else {
            try {
                await this.git.createStatus(Object.assign(Object.assign(Object.assign({}, options), msg), { target_url,
                    sha }));
                this.logger.log.success("Posted status to Pull Request.");
            }
            catch (error) {
                throw new Error(`Failed to post status to Pull Request with error code ${error.status}`);
            }
        }
        this.logger.verbose.success("Finished `pr-check` command");
    }
    /**
     * Comment on a PR. Only one comment will be present on the PR, Older comments are removed.
     * You can use the "context" option to multiple comments on a PR.
     *
     * @param args - Options for the comment functionality
     */
    async comment(args) {
        const options = Object.assign(Object.assign({}, this.getCommandDefault("comment")), args);
        const { message, pr, context = "default", dryRun, delete: deleteFlag, edit: editFlag, } = options;
        if (!this.git) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'comment'");
        const prNumber = this.getPrNumber("comment", pr);
        if (dryRun) {
            if (deleteFlag) {
                this.logger.log.info(`Would have deleted comment on ${prNumber} under "${context}" context`);
            }
            else if (editFlag) {
                this.logger.log.info(`Would have edited the comment on ${prNumber} under "${context}" context.\n\nNew message: ${message}`);
            }
            else {
                this.logger.log.info(`Would have commented on ${prNumber} under "${context}" context:\n\n${message}`);
            }
        }
        else if (editFlag && message) {
            await this.git.editComment(message, prNumber, context);
            this.logger.log.success(`Edited comment on PR #${prNumber} under context "${context}"`);
        }
        else {
            if (deleteFlag) {
                await this.git.deleteComment(prNumber, context);
                this.logger.log.success(`Deleted comment on PR #${prNumber} under context "${context}"`);
            }
            if (message) {
                await this.git.createComment(message, prNumber, context);
                this.logger.log.success(`Commented on PR #${prNumber}`);
            }
        }
    }
    /**
     * Update the body of a PR with a message. Only one message will be present in the PR,
     * Older messages are removed. You can use the "context" option to multiple message
     * in a PR body.
     *
     * @param options - Options
     */
    async prBody(options) {
        const { message, pr, context = "default", dryRun, delete: deleteFlag, } = options;
        if (!this.git) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'pr-body'");
        const prNumber = this.getPrNumber("pr-body", pr);
        if (dryRun) {
            if (deleteFlag) {
                this.logger.log.info(`Would have deleted PR body on ${prNumber} under "${context}" context`);
            }
            else {
                this.logger.log.info(`Would have appended to PR body on ${prNumber} under "${context}" context:\n\n${message}`);
            }
        }
        else {
            if (deleteFlag) {
                await this.git.addToPrBody("", prNumber, context);
            }
            if (message) {
                await this.git.addToPrBody(message, prNumber, context);
            }
            this.logger.log.success(`Updated body on PR #${prNumber}`);
        }
    }
    /**
     * Calculate the version bump for the current state of the repository.
     */
    async version(options = {}) {
        this.logger.verbose.info("Using command: 'version'");
        const bump = await this.getVersion(options);
        console.log(bump);
    }
    /**
     * Calculate the the changelog and commit it.
     */
    async changelog(options) {
        this.logger.verbose.info("Using command: 'changelog'");
        await this.makeChangelog(options);
    }
    /**
     * Make a release to the git remote with the changes.
     */
    async runRelease(options = {}) {
        this.logger.verbose.info("Using command: 'release'");
        await this.makeRelease(options);
    }
    /** Create a canary (or test) version of the project */
    // eslint-disable-next-line complexity
    async canary(args = {}) {
        const options = Object.assign(Object.assign({}, this.getCommandDefault("canary")), args);
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        if (!this.hooks.canary.isUsed()) {
            this.logger.log.warn(endent_1.default `
        None of the plugins that you are using implement the \`canary\` command!

        "canary" releases are versions that are used solely to test changes. They make sense on some platforms (ex: npm) but not all!
        
        If you think your package manager has the ability to support canaries please file an issue or submit a pull request,
      `);
            process.exit(0);
        }
        if (!args.dryRun) {
            await this.checkClean();
        }
        let { pr, build } = await this.getPrEnvInfo();
        pr = options.pr ? String(options.pr) : pr;
        build = options.build ? String(options.build) : build;
        this.logger.verbose.info("Canary info found:", { pr, build });
        const from = (await this.git.shaExists("HEAD^")) ? "HEAD^" : "HEAD";
        const head = await this.release.getCommitsInRelease(from);
        const labels = head.map((commit) => commit.labels);
        const version = semver_3.calculateSemVerBump(labels, this.semVerLabels, this.config);
        if (version === semver_3.default.noVersion && !options.force) {
            this.logger.log.info("Skipping canary release due to PR being specifying no release. Use `auto canary --force` to override this setting");
            return;
        }
        let canaryVersion = "";
        let newVersion = "";
        if (pr) {
            canaryVersion = `${canaryVersion}.${pr}`;
        }
        if (build) {
            canaryVersion = `${canaryVersion}.${build}`;
        }
        if (!pr || !build) {
            canaryVersion = `${canaryVersion}.${await this.git.getSha(true)}`;
        }
        canaryVersion = `canary${canaryVersion}`;
        if (options.dryRun) {
            const lastRelease = await this.git.getLatestRelease();
            const current = await this.getCurrentVersion(lastRelease);
            if (semver_1.parse(current)) {
                const next = determineNextVersion(lastRelease, current, version, canaryVersion);
                if (options.quiet) {
                    console.log(next);
                }
                else {
                    this.logger.log.warn(`Published canary identifier would be: ${next}`);
                }
            }
            else if (options.quiet) {
                console.log(`-${canaryVersion}`);
            }
            else {
                this.logger.log.warn(`Published canary identifier would be: "-${canaryVersion}"`);
            }
        }
        else {
            this.logger.verbose.info("Calling canary hook");
            const result = await this.hooks.canary.promise(version, canaryVersion);
            if (typeof result === "object" && "error" in result) {
                this.logger.log.warn(result.error);
                return;
            }
            if (!result) {
                return;
            }
            newVersion = typeof result === "string" ? result : result.newVersion;
            const messageHeader = (options.message || "ðŸ“¦ Published PR as canary version: %v").replace("%v", !newVersion || newVersion.includes("\n")
                ? newVersion
                : `<code>${newVersion}</code>`);
            if (options.message !== "false" && pr) {
                const message = typeof result === "string"
                    ? messageHeader
                    : makeDetail(messageHeader, result.details);
                await this.prBody({
                    pr: Number(pr),
                    context: "canary-version",
                    message,
                });
            }
            this.logger.log.success(`Published canary version${newVersion ? `: ${newVersion}` : ""}`);
            if (args.quiet) {
                console.log(newVersion);
            }
            await git_reset_1.gitReset();
        }
        let latestTag;
        try {
            latestTag = await this.git.getLatestTagInBranch();
        }
        catch (error) {
            latestTag = await this.git.getFirstCommit();
        }
        const commitsInRelease = await this.release.getCommits(latestTag);
        return { newVersion, commitsInRelease, context: "canary" };
    }
    /**
     * Create a next (or test) version of the project. If on master will
     * release to the default "next" branch.
     */
    async next(args) {
        var _a;
        const options = Object.assign(Object.assign({}, this.getCommandDefault("next")), args);
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        if (!this.hooks.next.isUsed()) {
            this.logger.log.warn(endent_1.default `
        None of the plugins that you are using implement the \`next\` command!

        "next" releases are pre-releases such as betas or alphas. They make sense on some platforms (ex: npm) but not all!

        If you think your package manager has the ability to support "next" releases please file an issue or submit a pull request,
      `);
            process.exit(0);
        }
        if (!args.dryRun) {
            await this.checkClean();
        }
        await this.setGitUser();
        this.hooks.onCreateLogParse.tap("Omit merges from master", (logParse) => {
            logParse.hooks.omitCommit.tap("Omit merges from master", (commit) => {
                const shouldOmit = commit.subject.match(/^Merge (?:\S+\/)*master/);
                this.logger.verbose.info(`Omit merges from master?" ${shouldOmit}: ${commit.subject}`);
                if (shouldOmit) {
                    return true;
                }
            });
        });
        const currentBranch = get_current_branch_1.getCurrentBranch();
        const initialForkCommit = ((await exec_promise_1.default("git", [
            "rev-list",
            "--boundary",
            `${currentBranch}...origin/${this.baseBranch}`,
            "--left-only",
        ]))
            .split("\n")
            .filter((line) => line.startsWith("-"))[0] || "").slice(1);
        const lastRelease = initialForkCommit || (await this.git.getLatestRelease());
        const lastTag = await this.git.getLastTagNotInBaseBranch(currentBranch);
        const fullReleaseNotes = await this.release.generateReleaseNotes(lastRelease);
        const commits = await this.release.getCommitsInRelease(lastTag);
        const releaseNotes = await this.release.generateReleaseNotes(lastTag);
        const labels = commits.map((commit) => commit.labels);
        const bump = semver_3.calculateSemVerBump(labels, this.semVerLabels, this.config) ||
            semver_3.default.patch;
        if (!args.quiet) {
            this.logger.log.info("Full Release notes for next release:");
            console.log(fullReleaseNotes);
            if (releaseNotes) {
                this.logger.log.info("Release notes for last change in next release");
                console.log(releaseNotes);
            }
        }
        if (options.dryRun) {
            const lastRelease = await this.git.getLatestRelease();
            const current = await this.getCurrentVersion(lastRelease);
            if (semver_1.parse(current)) {
                const prereleaseBranches = (_a = this.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches;
                const branch = get_current_branch_1.getCurrentBranch() || "";
                const prereleaseBranch = prereleaseBranches.includes(branch)
                    ? branch
                    : prereleaseBranches[0];
                const prerelease = determineNextVersion(lastRelease, current, bump, prereleaseBranch);
                if (options.quiet) {
                    console.log(prerelease);
                }
                else {
                    this.logger.log.success(`Would have created prerelease version: ${prerelease}`);
                }
            }
            else if (options.quiet) {
                // The following cases could use some work. They are really just there for lerna independent
                console.log(`${bump} on ${lastTag}`);
            }
            else {
                this.logger.log.success(`Would have created prerelease version with: ${bump} on ${lastTag}`);
            }
            return { newVersion: "", commitsInRelease: commits, context: "next" };
        }
        this.logger.verbose.info(`Calling "next" hook with: ${bump}`);
        const result = await this.hooks.next.promise([], bump);
        const newVersion = result.join(", ");
        await Promise.all(result.map(async (prerelease) => {
            var _a;
            const release = await ((_a = this.git) === null || _a === void 0 ? void 0 : _a.publish(releaseNotes, prerelease, true));
            this.logger.verbose.info(release);
            await this.hooks.afterRelease.promise({
                lastRelease: lastTag,
                newVersion: prerelease,
                commits,
                releaseNotes,
                response: release,
            });
        }));
        this.logger.log.success(`Published next version${result.length > 1 ? `s` : ""}: ${newVersion}`);
        const { pr } = await this.getPrEnvInfo();
        if (pr) {
            const message = options.message || "Published prerelease version: %v";
            if (pr) {
                await this.prBody({
                    pr: Number(pr),
                    context: "prerelease-version",
                    message: endent_1.default `
            # Version

            ${message.replace("%v", result.map((r) => `\`${r}\``).join("\n"))}

            <details>
              <summary>Changelog</summary>

              ${fullReleaseNotes}
            </details>
          `,
                });
            }
        }
        if (options.quiet) {
            console.log(newVersion);
        }
        await git_reset_1.gitReset();
        return { newVersion, commitsInRelease: commits, context: "next" };
    }
    /** Force a release to latest and bypass `shipit` safeguards. */
    async latest(args = {}) {
        const options = Object.assign(Object.assign({}, this.getCommandDefault("latest")), args);
        return this.publishFullRelease(options);
    }
    /**
     * Run the full workflow.
     *
     * 1. Calculate version
     * 2. Make changelog
     * 3. Publish code
     * 4. Create a release
     */
    async shipit(args = {}) {
        var _a, _b;
        const options = Object.assign(Object.assign({}, this.getCommandDefault("shipit")), args);
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        this.logger.verbose.info("Using command: 'shipit'");
        const isPR = "isPr" in env && env.isPr;
        const from = (await this.git.shaExists("HEAD^")) ? "HEAD^" : "HEAD";
        const head = await this.release.getCommitsInRelease(from);
        // env-ci sets branch to target branch (ex: master) in some CI services.
        // so we should make sure we aren't in a PR just to be safe
        const currentBranch = get_current_branch_1.getCurrentBranch();
        const isBaseBrach = !isPR && currentBranch === this.baseBranch;
        const shouldGraduate = !options.onlyGraduateWithReleaseLabel ||
            (options.onlyGraduateWithReleaseLabel &&
                head[0].labels.some((l) => { var _a, _b; return (_b = (_a = this.semVerLabels) === null || _a === void 0 ? void 0 : _a.get("release")) === null || _b === void 0 ? void 0 : _b.includes(l); }));
        const isPrereleaseBranch = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches) === null || _b === void 0 ? void 0 : _b.some((branch) => currentBranch === branch);
        const publishPrerelease = isPrereleaseBranch ||
            (currentBranch === this.baseBranch &&
                options.onlyGraduateWithReleaseLabel);
        this.logger.veryVerbose.info({
            currentBranch,
            isBaseBrach,
            isPR,
            shouldGraduate,
            isPrereleaseBranch,
            publishPrerelease,
        });
        let publishInfo;
        let releaseType = "canary";
        if (isBaseBrach && shouldGraduate) {
            releaseType = "latest";
        }
        else if (this.inOldVersionBranch()) {
            releaseType = "old";
        }
        else if (publishPrerelease) {
            releaseType = "next";
        }
        await this.hooks.beforeShipIt.promise({ releaseType });
        if (releaseType === "latest") {
            publishInfo = await this.latest(options);
        }
        else if (releaseType === "old") {
            publishInfo = await this.oldRelease(options);
        }
        else if (releaseType === "next") {
            publishInfo = await this.next(options);
        }
        else {
            publishInfo = await this.canary(options);
            if (options.dryRun && !options.quiet) {
                this.logger.log.success("Below is what would happen upon merge of the current branch into master");
                await this.publishFullRelease(options);
            }
        }
        if (!publishInfo) {
            return;
        }
        const { newVersion, commitsInRelease, context } = publishInfo;
        await this.hooks.afterShipIt.promise(newVersion, commitsInRelease, {
            context,
        });
    }
    /** Get the latest version number of the project */
    async getCurrentVersion(lastRelease) {
        this.hooks.getPreviousVersion.tap("None", () => {
            this.logger.veryVerbose.info("No previous release found, using 0.0.0 as previous version.");
            return this.prefixRelease("0.0.0");
        });
        const lastVersion = await this.hooks.getPreviousVersion.promise();
        if (semver_1.parse(lastRelease) &&
            semver_1.parse(lastVersion) &&
            semver_1.gt(lastRelease, lastVersion)) {
            this.logger.veryVerbose.info("Using latest release as previous version");
            return lastRelease;
        }
        return lastVersion;
    }
    /**
     * A utility function for plugins to check the process for tokens.
     */
    checkEnv(pluginName, key) {
        if (!process.env[key]) {
            this.logger.log.warn(`${pluginName}: No "${key}" found in environment`);
        }
    }
    /** Make a release to an old version */
    async oldRelease(options) {
        var _a;
        const latestTag = await ((_a = this.git) === null || _a === void 0 ? void 0 : _a.getLatestTagInBranch());
        const result = await this.publishFullRelease(Object.assign(Object.assign({}, options), { from: latestTag }));
        if (result) {
            result.context = "old";
        }
        return result;
    }
    /** Publish a new version with changelog, publish, and release */
    async publishFullRelease(options) {
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        const version = await this.getVersion(options);
        this.logger.log.success(`Calculated version bump: ${version || "none"}`);
        if (version === "") {
            this.logger.log.info("No version published.");
            return;
        }
        const lastRelease = options.from || (await this.git.getLatestRelease());
        const commitsInRelease = await this.release.getCommitsInRelease(lastRelease);
        await this.makeChangelog(Object.assign(Object.assign({}, options), { quiet: undefined, noCommit: options.noChangelog }));
        if (!options.dryRun) {
            await this.checkClean();
            this.logger.verbose.info("Calling version hook");
            await this.hooks.version.promise(version);
            this.logger.verbose.info("Calling after version hook");
            await this.hooks.afterVersion.promise();
            this.logger.verbose.info("Calling publish hook");
            await this.hooks.publish.promise(version);
            this.logger.verbose.info("Calling after publish hook");
            await this.hooks.afterPublish.promise();
        }
        const newVersion = await this.makeRelease(options);
        if (options.dryRun) {
            const current = await this.getCurrentVersion(lastRelease);
            if (semver_1.parse(current)) {
                const next = semver_1.inc(current, version);
                if (options.quiet) {
                    console.log(next);
                }
                else {
                    this.logger.log.warn(`Published version would be: ${next}`);
                }
            }
        }
        else if (options.quiet) {
            console.log(newVersion);
        }
        return { newVersion, commitsInRelease, context: "latest" };
    }
    /** Get a pr number from user input or the env */
    getPrNumber(command, pr) {
        const prNumber = getPrNumberFromEnv(pr);
        if (!prNumber) {
            this.logger.log.error(endent_1.default `
          Could not detect PR number. ${command} must be run from either a PR or have the PR number supplied via the --pr flag.
          
          In some CIs your branch might be built before you open a PR and posting the canary version will fail. In this case subsequent builds should succeed. 
        `);
            process.exit(1);
        }
        return prNumber;
    }
    /** Create a client to interact with git */
    startGit(gitOptions) {
        if (!gitOptions.owner || !gitOptions.repo || !gitOptions.token) {
            throw new Error("Must set owner, repo, and GitHub token.");
        }
        this.logger.verbose.info("Options contain repo information.");
        // So that --verbose can be used on public CIs
        const tokenlessArgs = Object.assign(Object.assign({}, gitOptions), { token: `[Token starting with ${gitOptions.token.substring(0, 4)}]` });
        this.logger.verbose.info("Initializing GitHub API with:\n", tokenlessArgs);
        return new git_1.default({
            owner: gitOptions.owner,
            repo: gitOptions.repo,
            token: gitOptions.token,
            baseUrl: gitOptions.baseUrl,
            baseBranch: this.baseBranch,
            graphqlBaseUrl: gitOptions.graphqlBaseUrl,
            agent: gitOptions.agent,
        }, this.logger);
    }
    /** Calculate a version from a tag using labels */
    async getVersion({ from } = {}) {
        if (!this.git || !this.release) {
            throw this.createErrorMessage();
        }
        const isPrerelease = this.inPrereleaseBranch();
        const lastRelease = from ||
            (isPrerelease && (await this.git.getLatestTagInBranch())) ||
            (await this.git.getLatestRelease());
        const calculatedBump = await this.release.getSemverBump(lastRelease);
        const bump = (isPrerelease && semver_2.preVersionMap.get(calculatedBump)) || calculatedBump;
        this.versionBump = bump;
        return bump;
    }
    /** Make a changelog over a range of commits */
    async makeChangelog(args = {}) {
        const options = Object.assign(Object.assign({}, this.getCommandDefault("changelog")), args);
        const { dryRun, from, to, title, message = "Update CHANGELOG.md [skip ci]", noCommit, } = options;
        if (!this.release || !this.git) {
            throw this.createErrorMessage();
        }
        await this.setGitUser();
        if (title) {
            this.release.hooks.createChangelogTitle.tap("Changelog Flag", () => title);
        }
        const lastRelease = from || (await this.git.getLatestRelease());
        const bump = await this.release.getSemverBump(lastRelease, to);
        const releaseNotes = await this.release.generateReleaseNotes(lastRelease, to, this.versionBump);
        if (dryRun) {
            this.logger.log.info("Potential Changelog Addition:\n", releaseNotes);
            this.logger.verbose.info("`changelog` dry run complete.");
            return;
        }
        if (args.quiet) {
            console.log(releaseNotes);
        }
        else {
            this.logger.log.info("New Release Notes\n", releaseNotes);
        }
        const currentVersion = await this.getCurrentVersion(lastRelease);
        const context = {
            bump,
            commits: await this.release.getCommits(lastRelease, to || undefined),
            releaseNotes,
            lastRelease,
            currentVersion,
        };
        if (!noCommit) {
            await this.release.addToChangelog(releaseNotes, lastRelease, currentVersion);
            await this.hooks.beforeCommitChangelog.promise(context);
            await exec_promise_1.default("git", ["commit", "-m", `"${message}"`, "--no-verify"]);
            this.logger.verbose.info("Committed new changelog.");
        }
        await this.hooks.afterAddToChangelog.promise(context);
    }
    /** Make a release over a range of commits */
    async makeRelease(args = {}) {
        const options = Object.assign(Object.assign({}, this.getCommandDefault("release")), args);
        const { dryRun, from, useVersion, prerelease = false } = options;
        if (!this.release || !this.git) {
            throw this.createErrorMessage();
        }
        // This will usually resolve to something on head
        const [err, latestTag] = await await_to_js_1.default(this.git.getLatestTagInBranch());
        // If its a dry run we want to show what would happen. Otherwise no
        // tags indicates that something would definitely go wrong.
        if ((err === null || err === void 0 ? void 0 : err.message.includes("No names found")) && !args.dryRun) {
            this.logger.log.error(endent_1.default `
          Could not find any tags in the local repository. Exiting early.

          The "release" command creates GitHub releases for tags that have already been created in your repo.
          
          If there are no tags there is nothing to release. If you don't use "shipit" ensure you tag your releases with the new version number.
        `, "\n");
            this.logger.verbose.error(err);
            return process.exit(1);
        }
        const isPrerelease = prerelease || this.inPrereleaseBranch();
        let lastRelease = from ||
            (isPrerelease && (await this.git.getPreviousTagInBranch())) ||
            (await this.git.getLatestRelease());
        // Find base commit or latest release to generate the changelog to HEAD (new tag)
        this.logger.veryVerbose.info(`Using ${lastRelease} as previous release.`);
        if (lastRelease.match(/^\d+\.\d+\.\d+/)) {
            lastRelease = this.prefixRelease(lastRelease);
        }
        this.logger.log.info('Current "Latest Release" on Github:', lastRelease);
        const commitsInRelease = await this.release.getCommitsInRelease(lastRelease);
        const releaseNotes = await this.release.generateReleaseNotes(lastRelease, undefined, this.versionBump);
        this.logger.log.info(`Using release notes:\n${releaseNotes}`);
        const rawVersion = useVersion ||
            (isPrerelease && latestTag) ||
            (await this.getCurrentVersion(lastRelease)) ||
            latestTag;
        if (!rawVersion) {
            this.logger.log.error("Could not calculate next version from last tag.");
            return;
        }
        const newVersion = semver_1.parse(rawVersion)
            ? this.prefixRelease(rawVersion)
            : rawVersion;
        if (!dryRun &&
            semver_1.parse(newVersion) &&
            semver_1.parse(lastRelease) &&
            semver_1.eq(newVersion, lastRelease)) {
            this.logger.log.warn(`Nothing released to Github. Version to be released is the same as the latest release on Github: ${newVersion}`);
            return;
        }
        const release = await this.hooks.makeRelease.promise({
            dryRun,
            from: lastRelease,
            isPrerelease,
            newVersion,
            fullReleaseNotes: releaseNotes,
            commits: commitsInRelease,
        });
        if (release) {
            await this.hooks.afterRelease.promise({
                lastRelease,
                newVersion,
                commits: commitsInRelease,
                releaseNotes,
                response: release,
            });
        }
        return newVersion;
    }
    /** Create an auto initialization error */
    createErrorMessage() {
        return new Error(`Auto is not initialized! Make sure the have run Auto.loadConfig`);
    }
    /** Get the current git user */
    async getGitUser() {
        try {
            return {
                /** The git user is already set in the current env */
                system: true,
                email: await exec_promise_1.default("git", ["config", "user.email"]),
                name: await exec_promise_1.default("git", ["config", "user.name"]),
            };
        }
        catch (error) {
            this.logger.verbose.warn("Could not find git user or email configured in git config");
            if (!this.release) {
                return;
            }
            let { email, name } = this.release.config;
            this.logger.verbose.warn(`Got author from options: email: ${email}, name ${name}`);
            const packageAuthor = await this.hooks.getAuthor.promise();
            email = !email && packageAuthor ? packageAuthor.email : email;
            name = !name && packageAuthor ? packageAuthor.name : name;
            this.logger.verbose.warn(`Using author: ${name} <${email}>`);
            return { email, name };
        }
    }
    /**
     * Set the git user to make releases and commit with.
     */
    async setGitUser() {
        const user = await this.getGitUser();
        if (user && !user.system) {
            if (!env.isCi) {
                this.logger.log.note(endent_1.default `
          Detected local environment, will not set git user. This happens automatically in a CI environment.

          If a command fails manually run:

            - git config user.email your@email.com
            - git config user.name "Your Name"
        `);
                return;
            }
            if (user.email) {
                await exec_promise_1.default("git", ["config", "user.email", `"${user.email}"`]);
                this.logger.verbose.warn(`Set git email to ${user.email}`);
            }
            if (user.name) {
                await exec_promise_1.default("git", ["config", "user.name", `"${user.name}"`]);
                this.logger.verbose.warn(`Set git name to ${user.name}`);
            }
        }
    }
    /** Get the repo to interact with */
    async getRepo(config) {
        if (config.owner && config.repo) {
            return config;
        }
        const author = await this.hooks.getRepository.promise();
        if (!author || !author.owner || !author.repo) {
            this.logger.log.error(endent_1.default `
          Cannot find project owner and repository name!

          You must do one of the following: 

          - configure the repo for your package manager (ex: set "repository" in package.json)
          - configure your git remote 'origin' to point to your project on GitHub.
        `, "");
            process.exit(1);
        }
        return author;
    }
    /** Find the location of the extended configuration */
    getExtendedLocation(config) {
        let extendedLocation;
        try {
            if (config.extends) {
                extendedLocation = require.resolve(config.extends);
            }
        }
        catch (error) {
            this.logger.veryVerbose.error(error);
        }
        return extendedLocation;
    }
    /**
     * Apply all of the plugins in the config.
     */
    loadPlugins(config) {
        config.plugins = config.plugins || [is_binary_1.default() ? "git-tag" : "npm"];
        const extendedLocation = this.getExtendedLocation(config);
        const pluginsPaths = [
            require.resolve("./plugins/filter-non-pull-request"),
            ...config.plugins,
        ];
        pluginsPaths
            .map((plugin) => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        typeof plugin === "string" ? [plugin, {}] : plugin)
            .map((plugin) => load_plugins_1.loadPlugin(plugin, this.logger, extendedLocation))
            .filter((plugin) => Boolean(plugin))
            .forEach((plugin) => {
            this.logger.verbose.info(`Using ${plugin.name} Plugin...`);
            plugin.apply(this);
        });
    }
    /** Get the branch and build number when in CI environment */
    async getPrEnvInfo() {
        var _a, _b, _c, _d, _e, _f;
        // SailEnv falls back to commit SHA
        let pr;
        let build;
        if ("pr" in env && "build" in env) {
            ({ pr } = env);
            ({ build } = env);
        }
        else if ("pr" in env && "commit" in env) {
            ({ pr } = env);
            build = env.commit;
        }
        // If we haven't detected the PR from the env vars try to match
        // the commit to a PR
        if (env.isCi && !pr && ((_a = this.git) === null || _a === void 0 ? void 0 : _a.options.owner) && ((_b = this.git) === null || _b === void 0 ? void 0 : _b.options.repo)) {
            const commit = await this.git.getSha();
            const query = match_sha_to_pr_1.buildSearchQuery((_c = this.git) === null || _c === void 0 ? void 0 : _c.options.owner, (_d = this.git) === null || _d === void 0 ? void 0 : _d.options.repo, [commit]);
            if (query) {
                const result = await this.git.graphql(query);
                if (result === null || result === void 0 ? void 0 : result[`hash_${commit}`]) {
                    const number = (_f = (_e = result[`hash_${commit}`].edges[0]) === null || _e === void 0 ? void 0 : _e.node) === null || _f === void 0 ? void 0 : _f.number;
                    if (number) {
                        pr = String(number);
                    }
                }
            }
        }
        return { pr, build };
    }
    /** Get the default for a command from the config */
    getCommandDefault(name) {
        if (!this.config) {
            return {};
        }
        const commandConfig = this.config[name];
        return typeof commandConfig === "object" ? commandConfig : {};
    }
}
exports.default = Auto;
var init_2 = require("./init");
exports.InteractiveInit = init_2.default;
var get_current_branch_2 = require("./utils/get-current-branch");
exports.getCurrentBranch = get_current_branch_2.getCurrentBranch;
var validate_config_2 = require("./validate-config");
exports.validatePluginConfiguration = validate_config_2.validatePluginConfiguration;
var auto_1 = require("./auto");
exports.Auto = auto_1.default;
var semver_4 = require("./semver");
exports.SEMVER = semver_4.default;
var exec_promise_2 = require("./utils/exec-promise");
exports.execPromise = exec_promise_2.default;
var get_lerna_packages_1 = require("./utils/get-lerna-packages");
exports.getLernaPackages = get_lerna_packages_1.default;
var in_folder_1 = require("./utils/in-folder");
exports.inFolder = in_folder_1.default;
//# sourceMappingURL=auto.js.map