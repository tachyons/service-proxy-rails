"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const fs = tslib_1.__importStar(require("fs"));
const lodash_chunk_1 = tslib_1.__importDefault(require("lodash.chunk"));
const semver_1 = require("semver");
const util_1 = require("util");
const t = tslib_1.__importStar(require("io-ts"));
const typescript_memoize_1 = require("typescript-memoize");
const changelog_1 = tslib_1.__importDefault(require("./changelog"));
const log_parse_1 = tslib_1.__importDefault(require("./log-parse"));
const semver_2 = tslib_1.__importStar(require("./semver"));
const exec_promise_1 = tslib_1.__importDefault(require("./utils/exec-promise"));
const logger_1 = require("./utils/logger");
const make_hooks_1 = require("./utils/make-hooks");
const child_process_1 = require("child_process");
const match_sha_to_pr_1 = require("./match-sha-to-pr");
exports.releaseLabels = [
    semver_2.default.major,
    semver_2.default.minor,
    semver_2.default.patch,
    "skip",
    "release",
];
/** Determine if a label is a label used for versioning */
exports.isVersionLabel = (label) => exports.releaseLabels.includes(label);
const labelDefinitionRequired = t.type({
    /** The label text */
    name: t.string,
});
const labelDefinitionOptional = t.partial({
    /** A title to put in the changelog for the label */
    changelogTitle: t.string,
    /** The color of the label */
    color: t.string,
    /** The description of the label */
    description: t.string,
    /** What type of release this label signifies */
    releaseType: t.union([
        t.literal("none"),
        t.literal("skip"),
        ...exports.releaseLabels.map((l) => t.literal(l)),
    ]),
    /** Whether to overwrite the base label */
    overwrite: t.boolean,
});
exports.labelDefinition = t.intersection([
    labelDefinitionOptional,
    labelDefinitionRequired,
]);
exports.defaultLabels = [
    {
        name: "major",
        changelogTitle: "💥 Breaking Change",
        description: "Increment the major version when merged",
        releaseType: semver_2.default.major,
    },
    {
        name: "minor",
        changelogTitle: "🚀 Enhancement",
        description: "Increment the minor version when merged",
        releaseType: semver_2.default.minor,
    },
    {
        name: "patch",
        changelogTitle: "🐛 Bug Fix",
        description: "Increment the patch version when merged",
        releaseType: semver_2.default.patch,
    },
    {
        name: "skip-release",
        description: "Preserve the current version when merged",
        releaseType: "skip",
    },
    {
        name: "release",
        description: "Create a release when this pr is merged",
        releaseType: "release",
    },
    {
        name: "internal",
        changelogTitle: "🏠 Internal",
        description: "Changes only affect the internal API",
        releaseType: "none",
    },
    {
        name: "documentation",
        changelogTitle: "📝 Documentation",
        description: "Changes only affect the documentation",
        releaseType: "none",
    },
];
/** Construct a map of label => semver label */
exports.getVersionMap = (labels = exports.defaultLabels) => labels.reduce((semVer, { releaseType: type, name }) => {
    if (type && (exports.isVersionLabel(type) || type === "none")) {
        const list = semVer.get(type) || [];
        semVer.set(type, [...list, name]);
    }
    return semVer;
}, new Map());
const readFile = util_1.promisify(fs.readFile);
const writeFile = util_1.promisify(fs.writeFile);
/**
 * A class for interacting with the git remote
 */
class Release {
    /** Initialize the release manager */
    constructor(git, config = {
        baseBranch: "master",
        prereleaseBranches: ["next"],
        labels: exports.defaultLabels,
    }, logger = logger_1.dummyLog()) {
        this.config = config;
        this.logger = logger;
        this.hooks = make_hooks_1.makeReleaseHooks();
        this.versionLabels = exports.getVersionMap(config.labels);
        this.git = git;
    }
    /** Make the class that will generate changelogs for the project */
    async makeChangelog(version) {
        const project = await this.git.getProject();
        const changelog = new changelog_1.default(this.logger, {
            owner: this.git.options.owner,
            repo: this.git.options.repo,
            baseUrl: project.html_url,
            labels: this.config.labels,
            baseBranch: this.config.baseBranch,
            prereleaseBranches: this.config.prereleaseBranches,
        });
        this.hooks.onCreateChangelog.call(changelog, version);
        changelog.loadDefaultHooks();
        return changelog;
    }
    /**
     * Generate a changelog from a range of commits.
     *
     * @param from - sha or tag to start changelog from
     * @param to - sha or tag to end changelog at (defaults to HEAD)
     */
    async generateReleaseNotes(from, to = "HEAD", version) {
        const commits = await this.getCommitsInRelease(from, to);
        const changelog = await this.makeChangelog(version);
        return changelog.generateReleaseNotes(commits);
    }
    /** Get all the commits that will be included in a release */
    async getCommitsInRelease(from, to = "HEAD") {
        const allCommits = await this.getCommits(from, to);
        const allPrCommits = await Promise.all(allCommits
            .filter((commit) => commit.pullRequest)
            .map(async (commit) => {
            const [err, commits = []] = await await_to_js_1.default(this.git.getCommitsForPR(Number(commit.pullRequest.number)));
            return err ? [] : commits;
        }));
        const allPrCommitHashes = allPrCommits
            .filter(Boolean)
            .reduce((all, pr) => [...all, ...pr.map((subCommit) => subCommit.sha)], []);
        const uniqueCommits = allCommits.filter((commit) => (commit.pullRequest || !allPrCommitHashes.includes(commit.hash)) &&
            !commit.subject.includes("[skip ci]"));
        const commitsWithoutPR = uniqueCommits.filter((commit) => !commit.pullRequest);
        const batches = lodash_chunk_1.default(commitsWithoutPR, 10);
        const queries = await Promise.all(batches
            .map((batch) => match_sha_to_pr_1.buildSearchQuery(this.git.options.owner, this.git.options.repo, batch.map((c) => c.hash)))
            .filter((q) => Boolean(q))
            .map((q) => this.git.graphql(q)));
        const data = queries.filter((q) => Boolean(q));
        if (!data.length) {
            return uniqueCommits;
        }
        const commitsInRelease = [
            ...uniqueCommits,
        ];
        const logParse = await this.createLogParse();
        const entries = data.reduce((acc, result) => [...acc, ...Object.entries(result)], []);
        await Promise.all(entries
            .filter((result) => Boolean(result[1]))
            .map(([key, result]) => match_sha_to_pr_1.processQueryResult({
            sha: key,
            result,
            commitsWithoutPR,
            owner: this.git.options.owner,
            prereleaseBranches: this.config.prereleaseBranches,
        }))
            .filter((commit) => Boolean(commit))
            .map(async (commit) => {
            const index = commitsInRelease.findIndex((c) => c && c.hash === commit.hash);
            commitsInRelease[index] = await logParse.normalizeCommit(commit);
        }));
        return commitsInRelease.filter((commit) => Boolean(commit));
    }
    /** Update a changelog with a new set of release notes */
    async updateChangelogFile(title, releaseNotes, changelogPath) {
        const date = new Date().toDateString();
        let newChangelog = "#";
        if (title) {
            newChangelog += ` ${title}`;
        }
        newChangelog += ` (${date})\n\n${releaseNotes}`;
        if (fs.existsSync(changelogPath)) {
            this.logger.verbose.info("Old changelog exists, prepending changes.");
            const oldChangelog = await readFile(changelogPath, "utf8");
            newChangelog = `${newChangelog}\n\n---\n\n${oldChangelog}`;
        }
        await writeFile(changelogPath, newChangelog);
        this.logger.verbose.info("Wrote new changelog to filesystem.");
        await exec_promise_1.default("git", ["add", changelogPath]);
    }
    /**
     * Prepend a set of release notes to the changelog.md
     *
     * @param releaseNotes - Release notes to prepend to the changelog
     * @param lastRelease - Last release version of the code. Could be the first commit SHA
     * @param currentVersion - Current version of the code
     */
    async addToChangelog(releaseNotes, lastRelease, currentVersion) {
        this.hooks.createChangelogTitle.tapPromise("Default", async () => {
            let version;
            if (lastRelease.match(/\d+\.\d+\.\d+/)) {
                version = await this.calcNextVersion(lastRelease);
            }
            else {
                // lastRelease is a git sha. no releases have been made
                const bump = await this.getSemverBump(lastRelease);
                version = semver_1.inc(currentVersion, bump);
            }
            this.logger.verbose.info("Calculated next version to be:", version);
            if (!version) {
                return "";
            }
            return this.config.noVersionPrefix || version.startsWith("v")
                ? version
                : `v${version}`;
        });
        this.logger.verbose.info("Adding new changes to changelog.");
        const title = await this.hooks.createChangelogTitle.promise();
        await this.updateChangelogFile(title || "", releaseNotes, "CHANGELOG.md");
    }
    /**
     * Get a range of commits. The commits will have PR numbers and labels attached
     *
     * @param from - Tag or SHA to start at
     * @param to - Tag or SHA to end at (defaults to HEAD)
     */
    async getCommits(from, to = "HEAD") {
        this.logger.verbose.info(`Getting commits from ${from} to ${to}`);
        const gitlog = await this.git.getGitLog(from, to);
        this.logger.veryVerbose.info("Got gitlog:\n", gitlog);
        const logParse = await this.createLogParse();
        const commits = (await logParse.normalizeCommits(gitlog)).filter((commit) => {
            let released;
            try {
                // This determines:         Is this commit an ancestor of this commit?
                //                                       ↓                ↓
                child_process_1.execSync(`git merge-base --is-ancestor ${from} ${commit.hash}`, {
                    encoding: "utf8",
                });
                released = false;
            }
            catch (error) {
                try {
                    // --is-ancestor returned false so the commit might be **before** "from"
                    // so test if it is and do not release this commit again
                    // This determines:         Is this commit an ancestor of this commit?
                    //                                       ↓                ↓
                    child_process_1.execSync(`git merge-base --is-ancestor ${commit.hash} ${from}`, {
                        encoding: "utf8",
                    });
                    released = true;
                }
                catch (error) {
                    // neither commit is a parent of the other so include it
                    released = false;
                }
            }
            if (released) {
                const shortHash = commit.hash.slice(0, 8);
                this.logger.verbose.warn(`Commit already released, omitting: ${shortHash}: "${commit.subject}"`);
            }
            return !released;
        });
        this.logger.veryVerbose.info("Added labels to commits:\n", commits);
        return commits;
    }
    /** Go through the configured labels and either add them to the project or update them */
    async addLabelsToProject(labels, options = {}) {
        const oldLabels = ((await this.git.getProjectLabels()) || []).map((l) => l.toLowerCase());
        const labelsToCreate = labels.filter((label) => {
            if (label.releaseType === "release" &&
                !this.config.onlyPublishWithReleaseLabel) {
                return false;
            }
            if (label.releaseType === "skip" &&
                this.config.onlyPublishWithReleaseLabel) {
                return false;
            }
            return true;
        });
        if (!options.dryRun) {
            await Promise.all(labelsToCreate.map(async (label) => {
                if (oldLabels.some((o) => label.name.toLowerCase() === o)) {
                    return this.git.updateLabel(label);
                }
                return this.git.createLabel(label);
            }));
        }
        const repoMetadata = await this.git.getProject();
        const justLabelNames = labelsToCreate.reduce((acc, label) => [...acc, label.name], []);
        if (justLabelNames.length > 0) {
            const state = options.dryRun ? "Would have created" : "Created";
            this.logger.log.log(`${state} labels: ${justLabelNames.join(", ")}`);
        }
        else {
            const state = options.dryRun ? "would have been" : "were";
            this.logger.log.log(`No labels ${state} created, they must have already been present on your project.`);
        }
        if (options.dryRun) {
            return;
        }
        this.logger.log.log(`\nYou can see these, and more at ${repoMetadata.html_url}/labels`);
    }
    /**
     * Calculate the SEMVER bump over a range of commits using the PR labels
     *
     * @param from - Tag or SHA to start at
     * @param to - Tag or SHA to end at (defaults to HEAD)
     */
    async getSemverBump(from, to = "HEAD") {
        const commits = await this.getCommits(from, to);
        const labels = commits.map((commit) => commit.labels);
        const { onlyPublishWithReleaseLabel } = this.config;
        const options = { onlyPublishWithReleaseLabel };
        this.logger.verbose.info("Calculating SEMVER bump using:\n", {
            labels,
            versionLabels: this.versionLabels,
            options,
        });
        const result = semver_2.calculateSemVerBump(labels, this.versionLabels, options);
        this.logger.verbose.success("Calculated SEMVER bump:", result);
        return result;
    }
    /** Given a tag get the next incremented version */
    async calcNextVersion(lastTag) {
        const bump = await this.getSemverBump(lastTag);
        return semver_1.inc(lastTag, bump);
    }
    /** Create the class that will parse the log for PR info */
    async createLogParse() {
        const logParse = new log_parse_1.default();
        logParse.hooks.parseCommit.tapPromise("Author Info", async (commit) => this.attachAuthor(commit));
        logParse.hooks.parseCommit.tapPromise("PR Information", async (commit) => this.addPrInfoToCommit(commit));
        logParse.hooks.parseCommit.tapPromise("PR Commits", async (commit) => {
            const prsSinceLastRelease = await this.getPRsSinceLastRelease();
            return this.getPRForRebasedCommits(commit, prsSinceLastRelease);
        });
        this.hooks.onCreateLogParse.call(logParse);
        return logParse;
    }
    /** Get a the PRs that have been merged since the last GitHub release. */
    async getPRsSinceLastRelease() {
        let lastRelease;
        try {
            lastRelease = await this.git.getLatestReleaseInfo();
        }
        catch (error) {
            const firstCommit = await this.git.getFirstCommit();
            lastRelease = {
                published_at: await this.git.getCommitDate(firstCommit),
            };
        }
        if (!lastRelease) {
            return [];
        }
        const prsSinceLastRelease = await this.git.searchRepo({
            q: `is:pr is:merged merged:>=${lastRelease.published_at}`,
        });
        if (!prsSinceLastRelease || !prsSinceLastRelease.items) {
            return [];
        }
        const data = await Promise.all(prsSinceLastRelease.items.map(async (pr) => this.git.getPullRequest(Number(pr.number))));
        return data.map((item) => item.data);
    }
    /**
     * Add the PR info (labels and body) to the commit
     *
     * @param commit - Commit to modify
     */
    async addPrInfoToCommit(commit) {
        const modifiedCommit = Object.assign({}, commit);
        if (!modifiedCommit.labels) {
            modifiedCommit.labels = [];
        }
        if (modifiedCommit.pullRequest) {
            const [err, info] = await await_to_js_1.default(this.git.getPr(modifiedCommit.pullRequest.number));
            if (err || !info || !info.data) {
                return modifiedCommit;
            }
            const labels = info ? info.data.labels.map((l) => l.name) : [];
            modifiedCommit.labels = [
                ...new Set([...labels, ...modifiedCommit.labels]),
            ];
            modifiedCommit.pullRequest.body = info.data.body;
            modifiedCommit.subject = info.data.title || modifiedCommit.subject;
            const hasPrOpener = modifiedCommit.authors.some((author) => author.username === info.data.user.login);
            // If we can't find the use who opened the PR in authors attempt
            // to add that user.
            if (!hasPrOpener) {
                const user = await this.git.getUserByUsername(info.data.user.login);
                if (user) {
                    modifiedCommit.authors.push(Object.assign(Object.assign({}, user), { username: user.login }));
                }
            }
        }
        return modifiedCommit;
    }
    /**
     * Commits from rebased PRs do not have messages that tie them to a PR
     * Instead we have to find all PRs since the last release and try to match
     * their merge commit SHAs.
     */
    getPRForRebasedCommits(commit, pullRequests) {
        const matchPr = pullRequests.find((pr) => pr.merge_commit_sha === commit.hash);
        if (!commit.pullRequest && matchPr) {
            const labels = matchPr.labels.map((label) => label.name) || [];
            commit.labels = [...new Set([...labels, ...commit.labels])];
            commit.pullRequest = {
                number: matchPr.number,
            };
        }
        return commit;
    }
    /** Parse the commit for information about the author and any other author that might have helped. */
    async attachAuthor(commit) {
        var _a, _b;
        const modifiedCommit = Object.assign({}, commit);
        let resolvedAuthors = [];
        // If there is a pull request we will attempt to get the authors
        // from any commit in the PR
        if (modifiedCommit.pullRequest) {
            const [prCommitsErr, prCommits] = await await_to_js_1.default(this.git.getCommitsForPR(Number(modifiedCommit.pullRequest.number)));
            if (prCommitsErr || !prCommits) {
                return commit;
            }
            resolvedAuthors = await Promise.all(prCommits.map(async (prCommit) => {
                if (!prCommit.author) {
                    return prCommit.commit.author;
                }
                return Object.assign(Object.assign(Object.assign({}, prCommit.author), (await this.git.getUserByUsername(prCommit.author.login))), { hash: prCommit.sha });
            }));
        }
        else {
            const [, response] = await await_to_js_1.default(this.git.getCommit(commit.hash));
            if ((_b = (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.author) === null || _b === void 0 ? void 0 : _b.login) {
                const username = response.data.author.login;
                const author = await this.git.getUserByUsername(username);
                resolvedAuthors.push(Object.assign(Object.assign({ name: commit.authorName, email: commit.authorEmail }, author), { hash: commit.hash }));
            }
            else if (commit.authorEmail) {
                const author = await this.git.getUserByEmail(commit.authorEmail);
                resolvedAuthors.push(Object.assign(Object.assign({ email: commit.authorEmail, name: commit.authorName }, author), { hash: commit.hash }));
            }
        }
        modifiedCommit.authors = resolvedAuthors.map((author) => (Object.assign(Object.assign({}, author), (author && "login" in author ? { username: author.login } : {}))));
        modifiedCommit.authors.forEach((author) => {
            this.logger.veryVerbose.info(`Found author: ${author.username} ${author.email} ${author.name}`);
        });
        return modifiedCommit;
    }
}
tslib_1.__decorate([
    typescript_memoize_1.Memoize()
], Release.prototype, "makeChangelog", null);
tslib_1.__decorate([
    typescript_memoize_1.Memoize()
], Release.prototype, "getPRsSinceLastRelease", null);
exports.default = Release;
//# sourceMappingURL=release.js.map