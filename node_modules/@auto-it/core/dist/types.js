"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const t = tslib_1.__importStar(require("io-ts"));
const release_1 = require("./release");
const author = t.partial({
    /** The name of the author to make commits with */
    name: t.string,
    /** The email of the author to make commits with */
    email: t.string,
});
const githubInformation = t.partial({
    /** The github api to interact with */
    githubApi: t.string,
    /** The github graphql api to interact with */
    githubGraphqlApi: t.string,
    /** The branch that is used as the base. defaults to master */
    baseBranch: t.string,
});
const repoInformation = t.partial({
    /** The repo of to publish, might be set in package manager file. */
    repo: t.string,
    /** The owner of the repo to publish, might be set in package manager file. */
    owner: t.string,
});
const releaseCalculationOptions = t.partial({
    /** Instead of publishing every PR only publish when "release" label is present */
    onlyPublishWithReleaseLabel: t.boolean,
});
const logOptions = t.partial({
    /** Show more logs */
    verbose: t.union([t.boolean, t.tuple([t.boolean, t.boolean])]),
});
const globalOptions = t.partial({
    /** Another auto configuration to extend */
    extends: t.string,
    /** Labels that power auto */
    labels: t.array(release_1.labelDefinition),
    /** Branches to create pre-releases from */
    prereleaseBranches: t.array(t.string),
    /** Configured auto plugins */
    plugins: t.array(t.union([t.string, t.tuple([t.string, t.any])])),
    /** Whether to prefix the version with a "v" */
    noVersionPrefix: t.boolean,
    /**
     * Manage old version branches.
     * Can be a true or a custom version branch prefix.
     *
     * @default 'version-'
     */
    versionBranches: t.union([t.boolean, t.string]),
    /** Options to pass to "auto comment" */
    comment: t.partial({
        delete: t.boolean,
        edit: t.boolean,
    }),
    /** Options to pass to "auto changelog" */
    changelog: t.partial({
        message: t.string,
    }),
    /** Options to pass to "auto release" */
    release: t.partial({
        prerelease: t.boolean,
    }),
    /** Options to pass to "auto shipit" */
    shipit: t.partial({
        onlyGraduateWithReleaseLabel: t.boolean,
    }),
    /** Options to pass to "auto canary" */
    canary: t.partial({
        force: t.boolean,
        message: t.union([t.literal(false), t.string]),
    }),
    /** Options to pass to "auto next" */
    next: t.partial({
        message: t.string,
    }),
});
exports.autoRc = t.intersection([
    globalOptions,
    t.intersection([
        repoInformation,
        githubInformation,
        author,
        releaseCalculationOptions,
        logOptions,
    ]),
]);
exports.loadedAutoRc = t.intersection([
    exports.autoRc,
    t.type({
        /** Labels that power auto */
        labels: t.array(release_1.labelDefinition),
        /** Branches to create pre-releases from */
        prereleaseBranches: t.array(t.string),
        /** The branch that is used as the base. defaults to master */
        baseBranch: t.string,
    }),
]);
//# sourceMappingURL=types.js.map