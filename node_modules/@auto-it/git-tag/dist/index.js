"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@auto-it/core");
const semver_1 = require("semver");
/** Manage your projects version through just a git tag. */
class GitTagPlugin {
    constructor() {
        /** The name of the plugin */
        this.name = "git-tag";
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        /** Get the latest tag in the repo, if none then the first commit */
        async function getTag() {
            try {
                return await auto.git.getLatestTagInBranch();
            }
            catch (error) {
                return auto.prefixRelease("0.0.0");
            }
        }
        auto.hooks.getPreviousVersion.tapPromise(this.name, async () => {
            if (!auto.git) {
                throw new Error("Can't calculate previous version without Git initialized!");
            }
            return getTag();
        });
        auto.hooks.version.tapPromise(this.name, async (version) => {
            if (!auto.git) {
                return;
            }
            const lastTag = await getTag();
            const newTag = semver_1.inc(lastTag, version);
            if (!newTag) {
                auto.logger.log.info("No release found, doing nothing");
                return;
            }
            const prefixedTag = auto.prefixRelease(newTag);
            auto.logger.log.info(`Tagging new tag: ${lastTag} => ${prefixedTag}`);
            await core_1.execPromise("git", [
                "tag",
                prefixedTag,
                "-m",
                `"Update version to ${prefixedTag}"`,
            ]);
        });
        auto.hooks.next.tapPromise(this.name, async (preReleaseVersions, bump) => {
            var _a;
            if (!auto.git) {
                return preReleaseVersions;
            }
            const prereleaseBranches = (_a = auto.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches;
            const branch = core_1.getCurrentBranch() || "";
            const prereleaseBranch = prereleaseBranches.includes(branch)
                ? branch
                : prereleaseBranches[0];
            const lastRelease = await auto.git.getLatestRelease();
            const current = (await auto.git.getLastTagNotInBaseBranch(prereleaseBranch)) ||
                (await auto.getCurrentVersion(lastRelease));
            const prerelease = core_1.determineNextVersion(lastRelease, current, bump, prereleaseBranch);
            await core_1.execPromise("git", [
                "tag",
                prerelease,
                "-m",
                `"Tag pre-release: ${prerelease}"`,
            ]);
            await core_1.execPromise("git", ["push", auto.remote, "--tags"]);
            return preReleaseVersions;
        });
        auto.hooks.publish.tapPromise(this.name, async () => {
            auto.logger.log.info("Pushing new tag to GitHub");
            await core_1.execPromise("git", [
                "push",
                "--follow-tags",
                "--set-upstream",
                auto.remote,
                core_1.getCurrentBranch() || auto.baseBranch,
            ]);
        });
    }
}
exports.default = GitTagPlugin;
//# sourceMappingURL=index.js.map