"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const env_ci_1 = tslib_1.__importDefault(require("env-ci"));
const fs = tslib_1.__importStar(require("fs"));
const parse_author_1 = tslib_1.__importDefault(require("parse-author"));
const path_1 = tslib_1.__importDefault(require("path"));
const typescript_memoize_1 = require("typescript-memoize");
const t = tslib_1.__importStar(require("io-ts"));
const child_process_1 = require("child_process");
const await_to_js_1 = tslib_1.__importDefault(require("await-to-js"));
const core_1 = require("@auto-it/core");
const get_monorepo_packages_1 = tslib_1.__importDefault(require("get-monorepo-packages"));
const semver_1 = require("semver");
const package_config_1 = tslib_1.__importDefault(require("./package-config"));
const set_npm_token_1 = tslib_1.__importDefault(require("./set-npm-token"));
const utils_1 = require("./utils");
const { isCi } = env_ci_1.default();
const VERSION_COMMIT_MESSAGE = '"Bump version to: %s [skip ci]"';
/** Check if the project is a monorepo */
const isMonorepo = () => fs.existsSync("lerna.json");
/** Get the last published version for a npm package */
async function getPublishedVersion(name) {
    try {
        return await core_1.execPromise("npm", ["view", name, "version"]);
    }
    catch (error) { }
}
/**
 * Determine the greatest version between last published version of a
 * package and the version in the package.json.
 */
async function greaterRelease(prefixRelease, name, packageVersion, prereleaseBranch) {
    const publishedVersion = await getPublishedVersion(name);
    if (!publishedVersion) {
        return packageVersion;
    }
    const publishedPrefixed = prefixRelease(publishedVersion);
    // The branch (ex: next) is also the --preid
    const baseVersion = prereleaseBranch && packageVersion.includes(prereleaseBranch)
        ? semver_1.inc(packageVersion, "patch") || packageVersion
        : packageVersion;
    return semver_1.gte(baseVersion, publishedPrefixed)
        ? packageVersion
        : publishedPrefixed;
}
exports.greaterRelease = greaterRelease;
/**
 * Determine what packages in a monorepo have git changes.
 * We are specifically not using `lerna changed` here because
 * we only care about the package that changed, not what other
 * packages that might effect.
 */
async function getChangedPackages({ sha, packages, lernaJson, logger, version, }) {
    const changed = new Set();
    const changedFiles = child_process_1.execSync(`git --no-pager show --first-parent ${sha} --name-only --pretty=`, { encoding: "utf8" });
    changedFiles.split("\n").forEach((filePath) => {
        const monorepoPackage = packages.find((subPackage) => core_1.inFolder(subPackage.path, filePath));
        if (!monorepoPackage) {
            return;
        }
        changed.add(lernaJson.version === "independent"
            ? `${monorepoPackage.name}@${semver_1.inc(monorepoPackage.version, version)}`
            : monorepoPackage.name);
    });
    if (changed.size > 0) {
        logger.veryVerbose.info(`Got changed packages for ${sha}:\n`, changed);
    }
    return [...changed];
}
exports.getChangedPackages = getChangedPackages;
/** Get the package with the greatest version in a monorepo */
function getMonorepoPackage() {
    const packages = get_monorepo_packages_1.default(process.cwd());
    return packages.reduce((greatest, subPackage) => {
        if (subPackage.package.version) {
            if (!greatest.version) {
                return subPackage.package;
            }
            if (subPackage.package.private) {
                return greatest;
            }
            return semver_1.gt(greatest.version, subPackage.package.version)
                ? greatest
                : subPackage.package;
        }
        return greatest;
    }, {});
}
exports.getMonorepoPackage = getMonorepoPackage;
/** Get all of the packages+version in the lerna monorepo */
async function getPackageList() {
    return core_1.getLernaPackages().then((packages) => packages.map((p) => `${p.name}@${p.version.split("+")[0]}`));
}
/**
 * Increment the version number of a package based the bigger
 * release between the last published version and the version
 * in the package.json.
 */
async function bumpLatest({ version: localVersion, name }, version) {
    const latestVersion = localVersion
        ? await greaterRelease((s) => s, name, localVersion)
        : undefined;
    return latestVersion ? semver_1.inc(latestVersion, version) : version;
}
const pluginOptions = t.partial({
    /** Whether to create sub-package changelogs */
    subPackageChangelogs: t.boolean,
    /** Whether to set the npm token on CI */
    setRcToken: t.boolean,
    /** Whether to force publish all the packages in a monorepo */
    forcePublish: t.boolean,
    /** A scope to publish canary versions under */
    canaryScope: t.string,
    /** Publish a monorepo with the lerna --exact flag */
    exact: t.boolean,
});
/** Parse the lerna.json file. */
const getLernaJson = () => {
    try {
        return JSON.parse(fs.readFileSync("lerna.json", "utf8"));
    }
    catch (error) {
        return {};
    }
};
/** Render a list of string in markdown */
const markdownList = (lines) => lines.map((line) => `- \`${line}\``).join("\n");
/** Get the previous version. Typically from a package distribution description file. */
async function getPreviousVersion(auto, prereleaseBranch) {
    let previousVersion = "";
    if (isMonorepo()) {
        auto.logger.veryVerbose.info("Using monorepo to calculate previous release");
        const monorepoVersion = getLernaJson().version;
        if (monorepoVersion === "independent") {
            previousVersion =
                "dryRun" in auto.options && auto.options.dryRun
                    ? markdownList(await getPackageList())
                    : "";
        }
        else {
            const releasedPackage = getMonorepoPackage();
            if (!releasedPackage.name && !releasedPackage.version) {
                previousVersion = auto.prefixRelease(monorepoVersion);
            }
            else {
                previousVersion = await greaterRelease(auto.prefixRelease, releasedPackage.name, auto.prefixRelease(monorepoVersion), prereleaseBranch);
            }
        }
    }
    else if (fs.existsSync("package.json")) {
        auto.logger.veryVerbose.info("Using package.json to calculate previous version");
        const { version, name } = await utils_1.loadPackageJson();
        previousVersion = version
            ? await greaterRelease(auto.prefixRelease, name, auto.prefixRelease(version), prereleaseBranch)
            : "0.0.0";
    }
    auto.logger.verbose.info("NPM: Got previous version from package.json", previousVersion);
    return previousVersion;
}
/** Remove the @ sign */
const sanitizeScope = (canaryScope) => canaryScope.replace("@", "");
/** Add a npm scope to a package name. Can have leading @ or not. */
const addCanaryScope = (canaryScope, name) => `@${sanitizeScope(canaryScope)}/${name}`;
/** Change the scope of all the packages to the canary scope */
async function setCanaryScope(canaryScope, paths) {
    const packages = await Promise.all(paths.map(async (p) => [p, await utils_1.loadPackageJson(p)]));
    const names = packages.map(([, p]) => p.name);
    await Promise.all(packages.map(async ([p, packageJson]) => {
        const newJson = Object.assign({}, packageJson);
        const name = packageJson.name.match(/@\S+\/\S+/)
            ? packageJson.name.split("/")[1]
            : packageJson.name;
        newJson.name = addCanaryScope(canaryScope, name);
        if (newJson.dependencies) {
            Object.keys(newJson.dependencies).forEach((d) => {
                if (names.includes(d)) {
                    const depName = d.match(/@\S+\/\S+/) ? d.split("/")[1] : d;
                    newJson.dependencies[addCanaryScope(canaryScope, depName)] = newJson.dependencies[d];
                    delete newJson.dependencies[d];
                }
            });
        }
        await utils_1.writeFile(path_1.default.join(p, "package.json"), JSON.stringify(newJson, null, 2));
    }));
}
/** Reset the scope changes of all the packages  */
async function gitReset() {
    await core_1.execPromise("git", ["reset", "--hard", "HEAD"]);
}
/** Make install instructions for multiple repos */
const makeMonorepoInstallList = (packageList) => [
    ":sparkles: Test out this PR locally via:\n",
    "```sh",
    ...packageList.map((p) => `npm install ${p}`),
    "# or ",
    ...packageList.map((p) => `yarn add ${p}`),
    "```",
].join("\n");
/** Publish to NPM. Works in both a monorepo setting and for a single package. */
class NPMPlugin {
    /** Initialize the plugin with it's options */
    constructor(config = {}) {
        /** The name of the plugin */
        this.name = "npm";
        this.exact = Boolean(config.exact);
        this.renderMonorepoChangelog = true;
        this.subPackageChangelogs =
            typeof config.subPackageChangelogs === "boolean"
                ? config.subPackageChangelogs
                : true;
        this.setRcToken =
            typeof config.setRcToken === "boolean" ? config.setRcToken : true;
        this.forcePublish =
            typeof config.forcePublish === "boolean" ? config.forcePublish : true;
        this.canaryScope = config.canaryScope || undefined;
    }
    /** A memoized version of getLernaPackages */
    async getLernaPackages() {
        return core_1.getLernaPackages();
    }
    /** Custom initialization for this plugin */
    init(initializer) {
        initializer.hooks.createEnv.tap(this.name, (vars) => [
            ...vars,
            {
                variable: "NPM_TOKEN",
                message: `Enter a npm token for publishing packages https://docs.npmjs.com/creating-and-viewing-authentication-tokens`,
            },
        ]);
        initializer.hooks.getAuthor.tapPromise(this.name, async () => {
            const packageJson = await utils_1.loadPackageJson();
            if (packageJson.author) {
                return true;
            }
            const author = await initializer.getAuthorInformation();
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.author = `${author.name} <${author.email}>`;
            await utils_1.writeFile("package.json", JSON.stringify(newPackageJson, null, 2));
            return true;
        });
        initializer.hooks.getRepo.tapPromise(this.name, async () => {
            const packageJson = await utils_1.loadPackageJson();
            if (packageJson.repository) {
                return true;
            }
            const repository = await initializer.getRepoInformation();
            const newPackageJson = Object.assign({}, packageJson);
            newPackageJson.repository = `${repository.owner}/${repository.repo}`;
            await utils_1.writeFile("package.json", JSON.stringify(newPackageJson, null, 2));
            return true;
        });
        initializer.hooks.writeRcFile.tapPromise(this.name, async (rc) => {
            const packageJson = await utils_1.loadPackageJson();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (packageJson.auto) {
                initializer.logger.log.note("Would have wrote configuration:\n", JSON.stringify(rc, null, 2));
                initializer.logger.log.warn("Found auto configuration in package.json. Doing nothing.");
            }
            else {
                await utils_1.writeFile("package.json", JSON.stringify(Object.assign(Object.assign({}, packageJson), { auto: rc }), null, 2));
                initializer.logger.log.success("Wrote configuration to package.json");
            }
            return true;
        });
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        var _a;
        const isQuiet = auto.logger.logLevel === "quiet";
        const isVerbose = auto.logger.logLevel === "verbose" ||
            auto.logger.logLevel === "veryVerbose";
        const verboseArgs = isQuiet
            ? ["--loglevel", "silent"]
            : isVerbose
                ? ["--loglevel", "silly"]
                : [];
        const prereleaseBranches = (_a = auto.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches;
        const branch = core_1.getCurrentBranch();
        // if ran from master we publish the prerelease to the first
        // configured prerelease branch
        const prereleaseBranch = branch && prereleaseBranches.includes(branch)
            ? branch
            : prereleaseBranches[0];
        auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {
            if (name === this.name || name === `@auto-it/${this.name}`) {
                return core_1.validatePluginConfiguration(this.name, pluginOptions, options);
            }
        });
        auto.hooks.modifyConfig.tap(this.name, (config) => {
            if (isMonorepo()) {
                const lernaJson = getLernaJson();
                if (lernaJson.tagVersionPrefix === "") {
                    return Object.assign(Object.assign({}, config), { noVersionPrefix: true });
                }
            }
            return config;
        });
        auto.hooks.beforeShipIt.tap(this.name, async () => {
            const isIndependent = getLernaJson().version === "independent";
            // In independent mode it's possible that no changes to packages have been
            // made, so no release will be made.
            if (isIndependent) {
                try {
                    await core_1.execPromise("yarn", ["lerna", "updated"]);
                }
                catch (error) {
                    auto.logger.log.warn("Lerna detected no changes in project. Aborting release since nothing would be published.");
                    auto.logger.verbose.warn(error);
                    process.exit(0);
                }
            }
            if (!isCi) {
                return;
            }
            auto.checkEnv(this.name, "NPM_TOKEN");
        });
        auto.hooks.getAuthor.tapPromise(this.name, async () => {
            auto.logger.verbose.info("NPM: Getting repo information from package.json");
            const packageJson = await utils_1.loadPackageJson();
            if (!packageJson.author) {
                return;
            }
            const { author } = packageJson;
            if (typeof author === "string") {
                return parse_author_1.default(author);
            }
            return author;
        });
        auto.hooks.getPreviousVersion.tapPromise(this.name, () => getPreviousVersion(auto, prereleaseBranch));
        auto.hooks.getRepository.tapPromise(this.name, async () => {
            auto.logger.verbose.info("NPM: getting repo information from package.json");
            const repo = await package_config_1.default();
            if (repo) {
                return repo;
            }
        });
        auto.hooks.onCreateRelease.tap(this.name, (release) => {
            release.hooks.createChangelogTitle.tap(`${this.name} - lerna independent`, () => {
                if (isMonorepo() && getLernaJson().version === "independent") {
                    return "";
                }
            });
        });
        auto.hooks.onCreateChangelog.tap(this.name, (changelog, version = core_1.SEMVER.patch) => {
            changelog.hooks.renderChangelogLine.tapPromise("NPM - Monorepo", async ([commit, line]) => {
                if (!isMonorepo() || !this.renderMonorepoChangelog) {
                    return [commit, line];
                }
                const lernaPackages = await this.getLernaPackages();
                const lernaJson = getLernaJson();
                const changedPackages = await getChangedPackages({
                    sha: commit.hash,
                    packages: lernaPackages,
                    lernaJson,
                    logger: auto.logger,
                    version,
                });
                const section = (changedPackages === null || changedPackages === void 0 ? void 0 : changedPackages.length) ? changedPackages.map((p) => `\`${p}\``).join(", ")
                    : "monorepo";
                if (section === "monorepo") {
                    return [commit, line];
                }
                return [commit, [`- ${section}`, `  ${line}`].join("\n")];
            });
        });
        auto.hooks.beforeCommitChangelog.tapPromise(this.name, async ({ commits, bump }) => {
            if (!isMonorepo() || !auto.release || !this.subPackageChangelogs) {
                return;
            }
            const lernaPackages = await core_1.getLernaPackages();
            const changelog = await auto.release.makeChangelog(bump);
            this.renderMonorepoChangelog = false;
            // Cannot run git operations in parallel
            await lernaPackages.reduce(async (last, lernaPackage) => {
                await last;
                auto.logger.verbose.info(`Updating changelog for: ${lernaPackage.name}`);
                const includedCommits = commits.filter((commit) => commit.files.some((file) => core_1.inFolder(lernaPackage.path, file)));
                const title = `v${semver_1.inc(lernaPackage.version, bump)}`;
                const releaseNotes = await changelog.generateReleaseNotes(includedCommits);
                if (releaseNotes.trim()) {
                    await auto.release.updateChangelogFile(title, releaseNotes, path_1.default.join(lernaPackage.path, "CHANGELOG.md"));
                }
            }, Promise.resolve());
            this.renderMonorepoChangelog = true;
        });
        auto.hooks.version.tapPromise(this.name, async (version) => {
            const isBaseBranch = branch === auto.baseBranch;
            if (isMonorepo()) {
                auto.logger.verbose.info("Detected monorepo, using lerna");
                const isIndependent = getLernaJson().version === "independent";
                const monorepoBump = isIndependent || !isBaseBranch
                    ? undefined
                    : await bumpLatest(getMonorepoPackage(), version);
                await core_1.execPromise("npx", [
                    "lerna",
                    "version",
                    monorepoBump || version,
                    !isIndependent && this.forcePublish && "--force-publish",
                    "--no-commit-hooks",
                    "--yes",
                    "--no-push",
                    "-m",
                    isIndependent
                        ? '"Bump independent versions [skip ci]"'
                        : VERSION_COMMIT_MESSAGE,
                    this.exact && "--exact",
                    ...verboseArgs,
                ]);
                auto.logger.verbose.info("Successfully versioned repo");
                return;
            }
            const latestBump = isBaseBranch
                ? await bumpLatest(await utils_1.loadPackageJson(), version)
                : version;
            await core_1.execPromise("npm", [
                "version",
                latestBump || version,
                "--no-commit-hooks",
                "-m",
                VERSION_COMMIT_MESSAGE,
                ...verboseArgs,
            ]);
            auto.logger.verbose.info("Successfully versioned repo");
        });
        auto.hooks.canary.tapPromise(this.name, async (bump, preid) => {
            if (this.setRcToken) {
                await set_npm_token_1.default(auto.logger);
                auto.logger.verbose.info("Set CI NPM_TOKEN");
            }
            const lastRelease = await auto.git.getLatestRelease();
            const [, latestTag = lastRelease] = await await_to_js_1.default(auto.git.getLatestTagInBranch());
            const inPrerelease = prereleaseBranches.some((b) => latestTag.includes(`-${b}.`));
            if (isMonorepo()) {
                const isIndependent = getLernaJson().version === "independent";
                auto.logger.verbose.info("Detected monorepo, using lerna");
                const packagesBefore = await core_1.getLernaPackages();
                const next = (isIndependent && `pre${bump}`) ||
                    core_1.determineNextVersion(lastRelease, inPrerelease ? latestTag : packagesBefore[0].version, bump, preid);
                if (this.canaryScope) {
                    await setCanaryScope(this.canaryScope, packagesBefore.map((p) => p.path));
                }
                await core_1.execPromise("npx", [
                    "lerna",
                    "publish",
                    next,
                    "--dist-tag",
                    "canary",
                    !isIndependent && "--force-publish",
                    "--yes",
                    "--no-git-reset",
                    "--no-git-tag-version",
                    "--exact",
                    ...(isIndependent ? ["--preid", preid] : []),
                    ...verboseArgs,
                ]);
                auto.logger.verbose.info("Successfully published canary version");
                const packages = await core_1.getLernaPackages();
                const packageList = await getPackageList();
                // Reset after we read the packages from the system!
                await gitReset();
                if (isIndependent) {
                    if (!packageList.some((p) => p.includes("canary"))) {
                        return { error: "No packages were changed. No canary published." };
                    }
                    return {
                        newVersion: "Canary Versions",
                        details: makeMonorepoInstallList(packageList.filter((p) => p.includes("canary"))),
                    };
                }
                const versioned = packages.find((p) => p.version.includes("canary"));
                if (!versioned) {
                    return { error: "No packages were changed. No canary published." };
                }
                const version = versioned.version.split("+")[0];
                return {
                    newVersion: this.canaryScope
                        ? `under canary scope @${sanitizeScope(this.canaryScope)}@${version}`
                        : version,
                    details: makeMonorepoInstallList(packageList),
                };
            }
            auto.logger.verbose.info("Detected single npm package");
            const current = await auto.getCurrentVersion(lastRelease);
            const canaryVersion = core_1.determineNextVersion(lastRelease, current, bump, preid);
            if (this.canaryScope) {
                await setCanaryScope(this.canaryScope, ["./"]);
            }
            await core_1.execPromise("npm", [
                "version",
                canaryVersion,
                "--no-git-tag-version",
                "--no-commit-hooks",
                ...verboseArgs,
            ]);
            const publishArgs = ["--tag", "canary"];
            await core_1.execPromise("npm", ["publish", ...publishArgs, ...verboseArgs]);
            if (this.canaryScope) {
                await gitReset();
            }
            const { name } = await utils_1.loadPackageJson();
            auto.logger.verbose.info("Successfully published canary version");
            return {
                newVersion: canaryVersion,
                details: makeMonorepoInstallList([`${name}@${canaryVersion}`]),
            };
        });
        auto.hooks.next.tapPromise(this.name, async (preReleaseVersions, bump) => {
            var _a;
            if (this.setRcToken) {
                await set_npm_token_1.default(auto.logger);
                auto.logger.verbose.info("Set CI NPM_TOKEN");
            }
            const lastRelease = await auto.git.getLatestRelease();
            const latestTag = (await ((_a = auto.git) === null || _a === void 0 ? void 0 : _a.getLastTagNotInBaseBranch(prereleaseBranch))) ||
                (await getPreviousVersion(auto, prereleaseBranch));
            if (isMonorepo()) {
                auto.logger.verbose.info("Detected monorepo, using lerna");
                const isIndependent = getLernaJson().version === "independent";
                // It's hard to accurately predict how we should bump independent versions.
                // So we just prerelease most of the time. (independent only)
                const next = isIndependent
                    ? "prerelease"
                    : core_1.determineNextVersion(lastRelease, latestTag, bump, prereleaseBranch);
                auto.logger.verbose.info({
                    lastRelease,
                    latestTag,
                    bump,
                    prereleaseBranch,
                    next,
                });
                await core_1.execPromise("npx", [
                    "lerna",
                    "publish",
                    next,
                    "--dist-tag",
                    prereleaseBranch,
                    "--preid",
                    prereleaseBranch,
                    "--no-push",
                    // you always want a next version to publish
                    !isIndependent && "--force-publish",
                    // skip prompts
                    "--yes",
                    // do not add ^ to next versions, this can result in `npm i` resolving the wrong next version
                    "--exact",
                    "--no-commit-hooks",
                    ...verboseArgs,
                ]);
                // we do not want to commit the next version. this causes
                // merge conflicts when merged into master. We also do not want
                // to re-implement the magic lerna does. So instead we let lerna
                // commit+tag the new version and roll back all the tags to the
                // previous commit.
                const tags = (await core_1.execPromise("git", ["tag", "--points-at", "HEAD"])).split("\n");
                await Promise.all(
                // Move tags back one commit
                tags.map((tag) => core_1.execPromise("git", ["tag", tag, "-f", "HEAD^"])));
                // Move branch back one commit
                await core_1.execPromise("git", ["reset", "--hard", "HEAD~1"]);
                auto.logger.verbose.info("Successfully published next version");
                preReleaseVersions = [
                    ...preReleaseVersions,
                    ...tags.map(auto.prefixRelease),
                ];
            }
            else {
                auto.logger.verbose.info("Detected single npm package");
                await core_1.execPromise("npm", [
                    "version",
                    core_1.determineNextVersion(lastRelease, latestTag, bump, prereleaseBranch),
                    // we do not want to commit the next version. this causes
                    // merge conflicts when merged into master
                    "--no-git-tag-version",
                    ...verboseArgs,
                ]);
                const { version } = await utils_1.loadPackageJson();
                await core_1.execPromise("git", [
                    "tag",
                    auto.prefixRelease(version),
                    "-m",
                    `"Update version to ${version}"`,
                ]);
                await core_1.execPromise("npm", [
                    "publish",
                    "--tag",
                    prereleaseBranch,
                    ...verboseArgs,
                ]);
                auto.logger.verbose.info("Successfully published next version");
                preReleaseVersions.push(auto.prefixRelease(version));
            }
            await core_1.execPromise("git", ["push", auto.remote, "--tags"]);
            return preReleaseVersions;
        });
        auto.hooks.publish.tapPromise(this.name, async () => {
            var _a;
            const status = await core_1.execPromise("git", ["status", "--porcelain"]);
            const isBaseBranch = branch === auto.baseBranch;
            // The only other time this hook is called is when creating a version
            // branch. So when on one of those branches publish to a tag of the same
            // name
            const tag = isBaseBranch
                ? []
                : [isMonorepo() ? "--dist-tag" : "--tag", branch];
            if (isVerbose && status) {
                auto.logger.log.error("Changed Files:\n", status);
            }
            if (this.setRcToken) {
                await set_npm_token_1.default(auto.logger);
                auto.logger.verbose.info("Set CI NPM_TOKEN");
            }
            if (isMonorepo()) {
                auto.logger.verbose.info("Detected monorepo, using lerna");
                if ((_a = auto.options) === null || _a === void 0 ? void 0 : _a.verbose) {
                    await core_1.execPromise("git", ["status", "--short"]);
                }
                await core_1.execPromise("npx", [
                    "lerna",
                    "publish",
                    ...tag,
                    "--yes",
                    // Plugins can add as many commits as they want, lerna will still
                    // publish the changed package versions. from-git broke when HEAD
                    // didn't contain the tags
                    "from-package",
                    ...verboseArgs,
                ]);
            }
            else {
                await core_1.execPromise("npm", ["publish", ...tag, ...verboseArgs]);
            }
            await core_1.execPromise("git", [
                "push",
                "--follow-tags",
                "--set-upstream",
                auto.remote,
                branch || auto.baseBranch,
            ]);
            auto.logger.verbose.info("Successfully published repo");
        });
        auto.hooks.makeRelease.tapPromise(this.name, async (options) => {
            const isIndependent = getLernaJson().version === "independent";
            // Independent mode will create multiple releases on Github.
            // Each release will only contain the release notes for the
            // package + global changes.
            if (!options.dryRun && isIndependent) {
                auto.logger.log.info(`Releasing ${options.newVersion} to GitHub.`);
                const changelog = await auto.release.makeChangelog();
                const lernaPackages = await core_1.getLernaPackages();
                // Go through each new tag:
                const newTags = (await core_1.execPromise("git", ["tag", "--points-at", "HEAD"])).split("\n");
                this.renderMonorepoChangelog = false;
                const packagePaths = lernaPackages.map((p) => p.path);
                const commitsAtRoot = options.commits.filter((commit) => !commit.files.some((file) => packagePaths.some((p) => core_1.inFolder(p, file))));
                const releases = await Promise.all(newTags.map(async (tag) => {
                    var _a;
                    const lernaPackage = lernaPackages.find((p) => tag.includes(p.name));
                    if (!lernaPackage) {
                        return;
                    }
                    auto.logger.log.info(`Releasing ${tag}...`);
                    // 1. generate release notes for just the commits for the package
                    const includedCommits = options.commits.filter((commit) => commit.files.some((file) => core_1.inFolder(lernaPackage.path, file)));
                    const releaseNotes = await changelog.generateReleaseNotes([
                        ...commitsAtRoot,
                        ...includedCommits,
                    ]);
                    auto.logger.log.info(`Using release notes:\n${releaseNotes}`);
                    // 2. make a release for just that package
                    if (releaseNotes.trim()) {
                        return (_a = auto.git) === null || _a === void 0 ? void 0 : _a.publish(releaseNotes, tag, options.isPrerelease);
                    }
                }));
                this.renderMonorepoChangelog = false;
                return releases.filter((release) => Boolean(release));
            }
        });
    }
}
tslib_1.__decorate([
    typescript_memoize_1.Memoize()
], NPMPlugin.prototype, "getLernaPackages", null);
exports.default = NPMPlugin;
//# sourceMappingURL=index.js.map