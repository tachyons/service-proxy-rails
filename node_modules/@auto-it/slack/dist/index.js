"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const slack_messages_1 = require("@atomist/slack-messages");
const core_1 = require("@auto-it/core");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const t = tslib_1.__importStar(require("io-ts"));
/** Transform markdown into slack friendly text */
const sanitizeMarkdown = (markdown) => slack_messages_1.githubToSlack(markdown)
    .split("\n")
    .map((line) => {
    // Strip out the ### prefix and replace it with *<word>* to make it bold
    if (line.startsWith("#")) {
        return `*${line.replace(/^[#]+/, "")}*`;
    }
    return line;
})
    .join("\n");
const pluginOptions = t.partial({
    /** URL of the slack to post to */
    url: t.string,
    /** Who to bother when posting to the channel */
    atTarget: t.string,
    /** Allow users to opt into having prereleases posted to slack */
    publishPreRelease: t.boolean,
});
/** Post your release notes to Slack during `auto release` */
class SlackPlugin {
    /** Initialize the plugin with it's options */
    constructor(options = {}) {
        /** The name of the plugin */
        this.name = "slack";
        if (typeof options === "string") {
            this.options = { url: options, atTarget: "channel" };
        }
        else {
            this.options = {
                url: process.env.SLACK_WEBHOOK_URL || options.url || "",
                atTarget: options.atTarget ? options.atTarget : "channel",
                publishPreRelease: options.publishPreRelease
                    ? options.publishPreRelease
                    : false,
            };
        }
    }
    /** Custom initialization for this plugin */
    init(initializer) {
        initializer.hooks.createEnv.tapPromise(this.name, async (vars) => [
            ...vars,
            {
                variable: "SLACK_WEBHOOK_URL",
                message: "What is the root url of your slack hook? ()",
            },
        ]);
    }
    /** Tap into auto plugin points. */
    apply(auto) {
        auto.hooks.validateConfig.tapPromise(this.name, async (name, options) => {
            // If it's a string thats valid config
            if (name === this.name && typeof options !== "string") {
                return core_1.validatePluginConfiguration(this.name, pluginOptions, options);
            }
        });
        auto.hooks.afterRelease.tapPromise(this.name, async ({ newVersion, commits, releaseNotes, response }) => {
            var _a, _b, _c;
            // Avoid publishing on prerelease branches by default, but allow folks to opt in if they care to
            const currentBranch = core_1.getCurrentBranch();
            if (currentBranch && ((_b = (_a = auto.config) === null || _a === void 0 ? void 0 : _a.prereleaseBranches) === null || _b === void 0 ? void 0 : _b.includes(currentBranch)) &&
                !this.options.publishPreRelease) {
                return;
            }
            if (!newVersion) {
                return;
            }
            const head = commits[0];
            if (!head) {
                return;
            }
            const skipReleaseLabels = (((_c = auto.config) === null || _c === void 0 ? void 0 : _c.labels.filter((l) => l.releaseType === "skip")) || []).map((l) => l.name);
            const isSkipped = head.labels.find((label) => skipReleaseLabels.includes(label));
            if (isSkipped) {
                return;
            }
            if (!this.options.url) {
                throw new Error("Slack url must be set to post a message to slack.");
            }
            await this.postToSlack(auto, newVersion, releaseNotes, (Array.isArray(response) && response) ||
                (response && [response]) ||
                []);
        });
    }
    /** Post the release notes to slack */
    async postToSlack(auto, newVersion, releaseNotes, releases) {
        if (!auto.git) {
            return;
        }
        auto.logger.verbose.info("Posting release notes to slack.");
        const body = sanitizeMarkdown(releaseNotes);
        const token = process.env.SLACK_TOKEN;
        const atTarget = this.options.atTarget;
        const urls = releases.map((release) => `*<${release.data.html_url}|${release.data.name}>*`);
        const releaseUrl = urls.length ? urls.join(", ") : newVersion;
        if (!token) {
            auto.logger.verbose.warn("Slack may need a token to send a message");
        }
        await node_fetch_1.default(`${this.options.url}${token ? `?token=${token}` : ""}`, {
            method: "POST",
            body: JSON.stringify({
                text: [`@${atTarget}: New release ${releaseUrl}`, body].join("\n"),
                link_names: 1,
            }),
            headers: { "Content-Type": "application/json" },
        });
        auto.logger.verbose.info("Posted release notes to slack.");
    }
}
exports.default = SlackPlugin;
//# sourceMappingURL=index.js.map