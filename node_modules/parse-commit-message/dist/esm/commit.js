import { EOL } from 'os';
import { isValidString } from './utils';
import { parseHeader, stringifyHeader, validateHeader } from './header';
export const FOO_BAR_QUX = 123;
export function parseCommit(commit) {
  if (!isValidString(commit)) {
    throw new TypeError(`expect \`commit\` to be non empty string`);
  }

  const header = parseHeader(commit);
  const [body = null, footer = null] = commit.split('\n\n').slice(1);
  return {
    header,
    body,
    footer
  };
}
export function stringifyCommit(commit) {
  const result = validateCommit(commit);

  if (result.error) {
    throw result.error;
  }

  const header = stringifyHeader(result.value.header);
  result.value.body = result.value.body ? EOL + EOL + result.value.body : '';
  result.value.footer = result.value.footer ? EOL + EOL + result.value.footer : '';
  return `${header}${result.value.body}${result.value.footer}`;
}
export function validateCommit(commit) {
  const result = {};

  try {
    result.value = checkCommit(commit);
  } catch (err) {
    return {
      error: err
    };
  }

  return result;
}
export function checkCommit(commit) {
  const {
    error,
    value: headerObj
  } = validateHeader(commit.header);

  if (error) {
    throw error;
  }

  const isValidBody = 'body' in commit && commit.body !== null ? typeof commit.body === 'string' : true;

  if (!isValidBody) {
    throw new TypeError('commit.body should be string when given');
  }

  const isValid = 'footer' in commit && commit.footer !== null ? typeof commit.footer === 'string' : true;

  if (!isValid) {
    throw new TypeError('commit.footer should be string when given');
  }

  return Object.assign({
    body: null,
    footer: null
  }, commit, {
    header: headerObj
  });
}